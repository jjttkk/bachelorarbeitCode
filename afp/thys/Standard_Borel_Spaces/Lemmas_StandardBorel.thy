(*  Title:   Lemmas_StandardBorel.thy
    Author:  Michikazu Hirata, Tokyo Institute of Technology
*)

text \<open> We refer to the HOL-Analysis library,
       the textbooks by Matsuzaka~\cite{topology} and Srivastava~\cite{borelsets},
       and the lecture note by Biskup~\cite{standardborel}.\<close>

section  \<open>Lemmas\<close>
theory Lemmas_StandardBorel
  imports "HOL-Probability.Probability"
begin

subsection \<open>Lemmas for Abstract Topology\<close>

subsubsection \<open> Generated By \<close>
lemma topology_generated_by_sub:
  assumes "\<And>U. U \<in> \<U> \<Longrightarrow> (openin X U)"
      and "openin (topology_generated_by \<U>) U"
    shows "openin X U"
proof -
  have "generate_topology_on \<U> U"
    by (simp add: assms(2) openin_topology_generated_by)
  then show ?thesis
    by induction (use assms(1) in auto)
qed

lemma topology_generated_by_open:
 "S = topology_generated_by {U | U . openin S U}"
  unfolding topology_eq
proof standard+
  fix U
  assume "openin (topology_generated_by {U |U. openin S U}) U"
  note this[simplified openin_topology_generated_by_iff]
  then show "openin S U"
    by induction auto
qed(simp add: openin_topology_generated_by_iff generate_topology_on.Basis)

lemma topology_generated_by_eq:
  assumes "\<And>U. U \<in> \<U> \<Longrightarrow> (openin (topology_generated_by \<O>) U)"
      and "\<And>U. U \<in> \<O> \<Longrightarrow> (openin (topology_generated_by \<U>) U)"
    shows "topology_generated_by \<O> = topology_generated_by \<U>"
  using topology_generated_by_sub[of \<U>, OF assms(1)] topology_generated_by_sub[of \<O>,OF assms(2)]
  by(auto simp: topology_eq)

lemma topology_generated_by_homeomorphic_spaces:
  assumes "homeomorphic_map X Y f" "X = topology_generated_by \<O>"
  shows "Y = topology_generated_by ((`) f ` \<O>)"
  unfolding topology_eq
proof
  have f:"open_map X Y f" "inj_on f (topspace X)"
    using assms(1) by (simp_all add: homeomorphic_imp_open_map perfect_injective_eq_homeomorphic_map[symmetric])
  obtain g where g: "\<And>x. x \<in> topspace X \<Longrightarrow> g (f x) = x" "\<And>y. y \<in> topspace Y \<Longrightarrow> f (g y) = y" "open_map Y X g" "inj_on g (topspace Y)"
    using homeomorphic_map_maps[of X Y f,simplified assms(1)] homeomorphic_imp_open_map homeomorphic_maps_map[of X Y f] homeomorphic_imp_injective_map[of Y X] by blast
  show "\<And>S. openin Y S = openin (topology_generated_by ((`) f ` \<O>)) S"
  proof safe
    fix S
    assume "openin Y S"
    then have "openin X (g ` S)"
      using g(3) by (simp add: open_map_def)
    hence h:"generate_topology_on \<O> (g ` S)"
      by(simp add: assms(2) openin_topology_generated_by_iff)
    have "S = f ` (g `  S)"
      using openin_subset[OF \<open>openin Y S\<close>] g(2) by(fastforce simp: image_def)
    also have "openin (topology_generated_by ((`) f ` \<O>)) ..."
      using h
    proof induction
      case Empty
      then show ?case by simp
    next
      case (Int a b)
      with inj_on_image_Int[OF f(2),of a b] show ?case
        by (metis assms(2) openin_Int openin_subset openin_topology_generated_by_iff)
    next
      case (UN K)
      then show ?case
        by(auto simp: image_Union)
    next
      case (Basis s)
      then show ?case
        by(auto intro!: generate_topology_on.Basis simp: openin_topology_generated_by_iff)
    qed
    finally show "openin (topology_generated_by ((`) f ` \<O>)) S" .
  next
    fix S
    assume "openin (topology_generated_by ((`) f ` \<O>)) S"
    then have "generate_topology_on ((`) f ` \<O>) S"
      by(simp add: openin_topology_generated_by_iff)
    thus "openin Y S"
    proof induction
      case (Basis s)
      then obtain U where u:"U \<in> \<O>" "s = f ` U" by auto
      then show ?case
        using assms(1) assms(2) homeomorphic_map_openness_eq topology_generated_by_Basis by blast
    qed auto
  qed
qed

lemma open_map_generated_topo:
  assumes "\<And>u. u \<in> U \<Longrightarrow> openin S (f ` u)" "inj_on f (topspace (topology_generated_by U))"
  shows "open_map (topology_generated_by U) S f"
  unfolding open_map_def
proof safe
  fix u
  assume "openin (topology_generated_by U) u"
  then have "generate_topology_on U u" 
    by(simp add: openin_topology_generated_by_iff)
  thus "openin S (f ` u)"
  proof induction
    case (Int a b)
    then have [simp]:"f ` (a \<inter> b) = f ` a \<inter> f ` b"
      by (meson assms(2) inj_on_image_Int openin_subset openin_topology_generated_by_iff)
    from Int show ?case by auto
  qed (simp_all add: image_Union openin_clauses(3) assms)
qed

lemma subtopology_generated_by:
 "subtopology (topology_generated_by \<O>) T = topology_generated_by {T \<inter> U | U. U \<in> \<O>}"
  unfolding topology_eq openin_subtopology openin_topology_generated_by_iff
proof safe
  fix A
  assume "generate_topology_on \<O> A"
  then show "generate_topology_on {T \<inter> U |U. U \<in> \<O>} (A \<inter> T)"
  proof induction
    case Empty
    then show ?case
      by (simp add: generate_topology_on.Empty)
  next
    case (Int a b)
    moreover have "a \<inter> b \<inter> T = (a \<inter> T) \<inter> (b \<inter> T)" by auto
    ultimately show ?case
      by(auto intro!: generate_topology_on.Int)
  next
    case (UN K)
    moreover have "(\<Union> K \<inter> T) = (\<Union> { k \<inter> T | k. k \<in> K})" by auto
    ultimately show ?case
      by(auto intro!: generate_topology_on.UN)
  next
    case (Basis s)
    then show ?case
      by(auto intro!: generate_topology_on.Basis)
  qed
next
  fix A
  assume "generate_topology_on {T \<inter> U |U. U \<in> \<O>} A"
  then show "\<exists>L. generate_topology_on \<O> L \<and> A = L \<inter> T"
  proof induction
    case Empty
    show ?case
      by(auto intro!: exI[where x="{}"] generate_topology_on.Empty)
  next
    case ih:(Int a b)
    then obtain La Lb where
     "generate_topology_on \<O> La" "a = La \<inter> T" "generate_topology_on \<O> Lb" "b = Lb \<inter> T"
      by auto
    thus ?case
      using ih by(auto intro!: exI[where x="La \<inter> Lb"] generate_topology_on.Int)
  next
    case ih:(UN K)
    then obtain L where
    "\<And>k. k \<in> K \<Longrightarrow> generate_topology_on \<O> (L k) " "\<And>k. k \<in> K \<Longrightarrow> k = (L k) \<inter> T"
      by metis
    thus ?case
      using ih by(auto intro!: exI[where x="\<Union>k\<in>K. L k"] generate_topology_on.UN)
  next
    case (Basis s)
    then show ?case
      using generate_topology_on.Basis by fastforce
  qed
qed

lemma prod_topology_generated_by:
  "topology_generated_by { U \<times> V | U V. U \<in> \<O> \<and> V \<in> \<U>} = prod_topology (topology_generated_by \<O>) (topology_generated_by \<U>)"
  unfolding topology_eq
proof safe
  fix U
  assume h:"openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) U"
  show "openin (prod_topology (topology_generated_by \<O>) (topology_generated_by \<U>)) U"
    by(auto simp: openin_prod_Times_iff[of "topology_generated_by \<O>" "topology_generated_by \<U>"]
          intro!: topology_generated_by_Basis topology_generated_by_sub[OF _ h])
next
  fix U
  assume "openin (prod_topology (topology_generated_by \<O>) (topology_generated_by \<U>)) U"
  then have "\<forall>z\<in>U. \<exists>V1 V2. openin (topology_generated_by \<O>) V1 \<and> openin (topology_generated_by \<U>) V2 \<and> fst z \<in> V1 \<and> snd z \<in> V2 \<and> V1 \<times> V2 \<subseteq> U"
    by(auto simp: openin_prod_topology_alt)
  hence "\<exists>V1. \<forall>z\<in>U. \<exists>V2. openin (topology_generated_by \<O>) (V1 z) \<and> openin (topology_generated_by \<U>) V2 \<and> fst z \<in> (V1 z) \<and> snd z \<in> V2 \<and> (V1 z) \<times> V2 \<subseteq> U"
    by(rule bchoice)
  then obtain V1 where "\<forall>z\<in>U. \<exists>V2. openin (topology_generated_by \<O>) (V1 z) \<and> openin (topology_generated_by \<U>) V2 \<and> fst z \<in> (V1 z) \<and> snd z \<in> V2 \<and> (V1 z) \<times> V2 \<subseteq> U"
    by auto
  hence "\<exists>V2. \<forall>z\<in>U. openin (topology_generated_by \<O>) (V1 z) \<and> openin (topology_generated_by \<U>) (V2 z) \<and> fst z \<in> (V1 z) \<and> snd z \<in> (V2 z) \<and> (V1 z) \<times> (V2 z) \<subseteq> U"
    by(rule bchoice)
  then obtain V2 where hv12:"\<And>z. z\<in>U \<Longrightarrow> openin (topology_generated_by \<O>) (V1 z) \<and> openin (topology_generated_by \<U>) (V2 z) \<and> fst z \<in> (V1 z) \<and> snd z \<in> (V2 z) \<and> (V1 z) \<times> (V2 z) \<subseteq> U"
    by auto
  hence 1:"U = (\<Union>z\<in>U. (V1 z) \<times> (V2 z))"
    by auto
  have "openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) (\<Union>z\<in>U. (V1 z) \<times> (V2 z))"
  proof(rule openin_Union)
    show "\<And>S. S \<in> (\<lambda>z. V1 z \<times> V2 z) ` U \<Longrightarrow> openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) S"
    proof safe
      fix x y
      assume h:"(x,y) \<in> U"
      then have "generate_topology_on \<O> (V1 (x,y))"
        using hv12 by(auto simp: openin_topology_generated_by_iff)
      thus "openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) (V1 (x, y) \<times> V2 (x, y))"
      proof induction
        case Empty
        then show ?case by auto
      next
        case (Int a b)
        thus ?case
          by (auto simp: Sigma_Int_distrib1) 
      next
        case (UN K)
        then have "openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) (\<Union>{ k \<times> V2 (x, y) | k. k \<in> K})"
          by auto
        moreover have "(\<Union> {k \<times> V2 (x, y) |k. k \<in> K}) = (\<Union> K \<times> V2 (x, y))"
          by blast
        ultimately show ?case by simp
      next
        case ho:(Basis s)
        have "generate_topology_on \<U> (V2 (x,y))"
          using h hv12 by(auto simp: openin_topology_generated_by_iff)
        thus ?case
        proof induction
          case Empty
          then show ?case by auto
        next
          case (Int a b)
          then show ?case
            by (auto simp: Sigma_Int_distrib2) 
        next
          case (UN K)
          then have "openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) (\<Union> { s \<times> k | k. k \<in>K})"
            by auto
          moreover have "(\<Union> { s \<times> k | k. k \<in>K}) = s \<times> \<Union>K"
            by blast
          ultimately show ?case by simp
        next
          case (Basis s')
          then show ?case
            using ho by(auto intro!: topology_generated_by_Basis)
        qed
      qed
    qed
  qed
  thus "openin (topology_generated_by {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<U>}) U"
    using 1 by auto
qed

lemma prod_topology_generated_by_open:
 "prod_topology S S' = topology_generated_by {U \<times> V | U V. openin S U \<and> openin S' V}"
  using prod_topology_generated_by[of " {U |U. openin S U}" "{U |U. openin S' U}"] topology_generated_by_open[of S,symmetric] topology_generated_by_open[of S']
  by auto

lemma product_topology_cong:
  assumes "\<And>i. i \<in> I \<Longrightarrow> S i = K i"
  shows "product_topology S I = product_topology K I"
proof -
  have 1:"{\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)}} \<subseteq> {\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (K i) (X i)) \<and> finite {i. X i \<noteq> topspace (K i)}}" if "\<And>i. i \<in> I \<Longrightarrow> S i = K i" for S K :: "_ \<Rightarrow> 'b topology"
  proof
    fix x
    assume hx:"x \<in> {\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)}}"
    then obtain X where hX:
     "x = (\<Pi>\<^sub>E i\<in>I. X i)" "\<And>i. openin (S i) (X i)" "finite {i. X i \<noteq> topspace (S i)}"
      by auto
    define X' where "X' \<equiv> (\<lambda>i. if i \<in> I then X i else topspace (K i))"
    have "x = (\<Pi>\<^sub>E i\<in>I. X' i)"
      by(auto simp: hX(1) X'_def PiE_def Pi_def)
    moreover have "finite {i. X' i \<noteq> topspace (K i)}"
      using that by(auto intro!: finite_subset[OF _ hX(3)] simp: X'_def)
    moreover have "openin (K i) (X' i)" for i
      using hX(2)[of i] that[of i] by(auto simp: X'_def)
    ultimately show "x \<in> {\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (K i) (X i)) \<and> finite {i. X i \<noteq> topspace (K i)}}"
      by(auto intro!: exI[where x="X'"])
  qed
  have "{\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)}} = {\<Pi>\<^sub>E i\<in>I. X i |X. (\<forall>i. openin (K i) (X i)) \<and> finite {i. X i \<noteq> topspace (K i)}}"
    using 1[of S K] 1[of K S] assms by auto
  thus ?thesis
    by(simp add: product_topology_def)
qed

lemma topology_generated_by_without_empty:
 "topology_generated_by \<O> = topology_generated_by { U \<in> \<O>. U \<noteq> {}}"
proof(rule topology_generated_by_eq)
  fix U
  show "U \<in> \<O> \<Longrightarrow> openin (topology_generated_by { U \<in> \<O>. U \<noteq> {}}) U"
    by(cases "U = {}") (simp_all add: topology_generated_by_Basis)
qed (simp add: topology_generated_by_Basis)

lemma topology_from_bij:
  assumes "bij_betw f A (topspace S)"
  shows "homeomorphic_map (pullback_topology A f S) S f" "topspace (pullback_topology A f S) = A"
proof -
  note h = bij_betw_imp_surj_on[OF assms] bij_betw_inv_into_left[OF assms] bij_betw_inv_into_right[OF assms]
  then show [simp]:"topspace (pullback_topology A f S) = A"
    by(auto simp: topspace_pullback_topology)
  show "homeomorphic_map (pullback_topology A f S) S f"
    by(auto simp: homeomorphic_map_maps homeomorphic_maps_def h continuous_map_pullback[OF continuous_map_id,simplified] inv_into_into intro!: exI[where x="inv_into A f"] continuous_map_pullback'[where f=f]) (metis (mono_tags, opaque_lifting) comp_apply continuous_map_eq continuous_map_id h(3) id_apply)
qed

lemma openin_pullback_topology':
  assumes "bij_betw f A (topspace S)"
  shows "openin (pullback_topology A f S) u \<longleftrightarrow> (openin S (f ` u)) \<and> u \<subseteq> A"
  unfolding openin_pullback_topology
proof safe
  fix U
  assume h:"openin S U" "u = f -` U \<inter> A"
  from openin_subset[OF this(1)] assms
  have [simp]:"f ` (f -` U \<inter> A) = U"
    by(auto simp: image_def vimage_def bij_betw_def)
  show "openin S (f ` (f -` U \<inter> A))"
    by(simp add: h)
next
  assume "openin S (f ` u)" "u \<subseteq> A"
  with assms show "\<exists>U. openin S U \<and> u = f -` U \<inter> A"
    by(auto intro!: exI[where x="f ` u"] simp: bij_betw_def inj_on_def)
qed

subsubsection \<open> Isolated Point \<close>    
definition isolated_points_of :: "'a topology \<Rightarrow> 'a set \<Rightarrow> 'a set" (infixr "isolated'_points'_of" 80) where
"X isolated_points_of A \<equiv> {x\<in>topspace X \<inter> A. x \<notin> X derived_set_of A}"

lemma isolated_points_of_eq:
 "X isolated_points_of A = {x\<in>topspace X \<inter> A. \<exists>U. x \<in> U \<and> openin X U \<and> U \<inter> (A - {x}) = {}}"
  unfolding isolated_points_of_def by(auto simp: in_derived_set_of)

lemma in_isolated_points_of:
 "x \<in> X isolated_points_of A \<longleftrightarrow> x \<in> topspace X \<and> x \<in> A \<and> (\<exists>U. x \<in> U \<and> openin X U \<and> U \<inter> (A - {x}) = {})"
  by(simp add: isolated_points_of_eq)

lemma derived_set_of_eq:
 "x \<in> X derived_set_of A \<longleftrightarrow> x \<in> X closure_of (A - {x})"
  by(auto simp: in_derived_set_of in_closure_of)

subsubsection \<open> Perfect Set \<close>
definition perfect_set :: "'a topology \<Rightarrow> 'a set \<Rightarrow> bool" where
"perfect_set X A \<longleftrightarrow> closedin X A \<and> X isolated_points_of A = {}"

abbreviation "perfect_space X \<equiv> perfect_set X (topspace X)"

lemma perfect_setI:
  assumes "closedin X A"
      and "\<And>x T. \<lbrakk>x \<in> A; x \<in> T; openin X T\<rbrakk> \<Longrightarrow> \<exists>y\<noteq>x. y \<in> T \<and> y \<in> A"
    shows "perfect_set X A"
  using assms by(simp add: perfect_set_def isolated_points_of_def in_derived_set_of) blast

lemma perfect_spaceI:
  assumes "\<And>x T. \<lbrakk>x \<in> T; openin X T\<rbrakk> \<Longrightarrow> \<exists>y\<noteq>x. y \<in> T"
  shows "perfect_space X"
  using assms by(auto intro!: perfect_setI) (meson in_mono openin_subset)

lemma perfect_setD:
  assumes "perfect_set X A"
  shows "closedin X A" "A \<subseteq> topspace X" "\<And>x T. \<lbrakk>x \<in> A; x \<in> T; openin X T\<rbrakk> \<Longrightarrow> \<exists>y\<noteq>x. y \<in> T \<and> y \<in> A"
  using assms closedin_subset[of X A] by(simp_all add: perfect_set_def isolated_points_of_def in_derived_set_of) blast

lemma perfect_space_perfect:
  "perfect_set euclidean (UNIV :: 'a :: perfect_space set)"
  by(auto simp: perfect_set_def in_isolated_points_of) (metis Int_Diff inf_top.right_neutral insert_Diff not_open_singleton)

lemma perfect_set_subtopology:
  assumes "perfect_set X A"
  shows "perfect_space (subtopology X A)"
  using perfect_setD[OF assms] by(auto intro!: perfect_setI simp: inf.absorb_iff2 openin_subtopology)

subsubsection \<open> Bases and Sub-Bases in Abstract Topology\<close>
definition subbase_of :: "['a topology, 'a set set] \<Rightarrow> bool" where
"subbase_of S \<O> \<longleftrightarrow> S = topology_generated_by \<O>"

definition base_of :: "['a topology, 'a set set] \<Rightarrow> bool" where
"base_of S \<O> \<longleftrightarrow> (\<forall>U. openin S U \<longleftrightarrow> (\<exists>\<U>. U = \<Union>\<U> \<and> \<U> \<subseteq> \<O>))"

definition second_countable :: "'a topology \<Rightarrow> bool" where
"second_countable S \<longleftrightarrow> (\<exists>\<O>. countable \<O> \<and> base_of S \<O>)"

definition zero_dimensional :: "'a topology \<Rightarrow> bool" where
"zero_dimensional S \<longleftrightarrow> (\<exists>\<O>. base_of S \<O> \<and> (\<forall>u\<in>\<O>. openin S u \<and> closedin S u))"

lemma openin_base:
  assumes "base_of S \<O> " "U = \<Union>\<U>" and "\<U> \<subseteq> \<O>"
  shows "openin S U"
  using assms by(auto simp: base_of_def)

lemma base_is_subbase:
  assumes "base_of S \<O>"
  shows "subbase_of S \<O>"
  unfolding subbase_of_def topology_eq openin_topology_generated_by_iff
proof safe
  fix U
  assume "openin S U"
  then obtain \<U> where hu:"U = \<Union>\<U>" "\<U> \<subseteq> \<O>"
    using assms by(auto simp: base_of_def)
  thus "generate_topology_on \<O> U"
    by(auto intro!: generate_topology_on.UN) (auto intro!:  generate_topology_on.Basis)
next
  fix U
  assume "generate_topology_on \<O> U"
  then show "openin S U"
  proof induction
    case (Basis s)
    then show ?case
      using openin_base[OF assms,of s "{s}"]
      by auto
  qed auto
qed

lemma subbase_of_subset:
  assumes "subbase_of S \<O>" and "U \<in> \<O>"
  shows "U \<subseteq> topspace S"
  using assms(1)[simplified subbase_of_def] topology_generated_by_topspace assms
  by auto

lemma subbase_of_openin:
  assumes "subbase_of S \<O>" and "U \<in> \<O>"
  shows "openin S U"
  using assms by(simp add: subbase_of_def openin_topology_generated_by_iff generate_topology_on.Basis)

lemma base_of_subset:
  assumes "base_of S \<O>" and "U \<in> \<O>"
  shows "U \<subseteq> topspace S"
  using subbase_of_subset[OF base_is_subbase[OF assms(1)] assms(2)] .

lemma base_of_openin:
  assumes "base_of S \<O>" and "U \<in> \<O>"
  shows "openin S U"
  using subbase_of_openin[OF base_is_subbase[OF assms(1)] assms(2)] .

lemma base_of_def2:
  assumes "\<And>U. U \<in> \<O> \<Longrightarrow> openin S U"
  shows "base_of S \<O> \<longleftrightarrow> (\<forall>U. openin S U \<longrightarrow> (\<forall>x\<in>U. \<exists>W\<in>\<O>. x \<in> W \<and> W \<subseteq> U))"
proof
  assume h:"base_of S \<O>"
  show "\<forall>U. openin S U \<longrightarrow> (\<forall>x\<in>U. \<exists>W\<in>\<O>. x \<in> W \<and> W \<subseteq> U)"
  proof safe
    fix U x
    assume h':"openin S U" "x \<in> U"
    then obtain \<U> where hu: "U = \<Union>\<U>" "\<U> \<subseteq> \<O>"
      using h by(auto simp: base_of_def)
    then obtain W where "x \<in> W" "W \<in> \<U>"
      using h'(2) by blast
    thus "\<exists>W\<in>\<O>. x \<in> W \<and> W \<subseteq> U"
      using hu by(auto intro!: bexI[where x=W])
  qed
next
  assume h:"\<forall>U. openin S U \<longrightarrow> (\<forall>x\<in>U. \<exists>W\<in>\<O>. x \<in> W \<and> W \<subseteq> U)"
  show "base_of S \<O>"
    unfolding base_of_def
  proof safe
    fix U
    assume "openin S U"
    then have "\<forall>x\<in>U. \<exists>W. W\<in>\<O> \<and> x \<in> W \<and> W \<subseteq> U"
      using h by blast
    hence "\<exists>W. \<forall>x\<in>U. W x \<in> \<O> \<and> x \<in> W x \<and> W x \<subseteq> U"
      by(rule bchoice)
    then obtain W where hw:
     "\<forall>x\<in>U. W x \<in> \<O> \<and> x \<in> W x \<and> W x \<subseteq> U" by auto
    thus "\<exists>\<U>. U = \<Union> \<U> \<and> \<U> \<subseteq> \<O>"
      by(auto intro!: exI[where x="W ` U"])
  next
    fix U \<U>
    show "\<U> \<subseteq> \<O> \<Longrightarrow> openin S (\<Union> \<U>)"
      using assms by auto
  qed
qed

lemma base_of_def2':
 "base_of S \<O> \<longleftrightarrow> (\<forall>b\<in>\<O>. openin S b) \<and> (\<forall>x. openin S x \<longrightarrow> (\<exists>B'\<subseteq>\<O>. \<Union> B' = x))"
proof
  assume h:"base_of S \<O>"
  show "(\<forall>b\<in>\<O>. openin S b) \<and> (\<forall>x. openin S x \<longrightarrow> (\<exists>B'\<subseteq>\<O>. \<Union> B' = x))"
  proof(rule conjI)
    show "\<forall>b\<in>\<O>. openin S b"
      using openin_base[OF h,of _ "{_}"] by auto
  next
    show "\<forall>x. openin S x \<longrightarrow> (\<exists>B'\<subseteq>\<O>. \<Union> B' = x)"
      using h by(auto simp: base_of_def)
  qed
next
  assume h:"(\<forall>b\<in>\<O>. openin S b) \<and> (\<forall>x. openin S x \<longrightarrow> (\<exists>B'\<subseteq>\<O>. \<Union> B' = x))"
  show "base_of S \<O>"
    unfolding base_of_def
  proof safe
    fix U
    assume "openin S U"
    then obtain B' where "B'\<subseteq>\<O>" "\<Union> B' = U"
      using h by blast
    thus "\<exists>\<U>. U = \<Union> \<U> \<and> \<U> \<subseteq> \<O>"
      by(auto intro!: exI[where x=B'])
  next
    fix U \<U>
    show "\<U> \<subseteq> \<O> \<Longrightarrow> openin S (\<Union> \<U>)"
      using h by auto
  qed
qed

corollary base_of_in_subset:
  assumes "base_of S \<O>" "openin S u" "x \<in> u"
  shows "\<exists>v\<in>\<O>. x \<in> v \<and> v \<subseteq> u"
  using assms base_of_def2 base_of_def2' by fastforce

lemma base_of_without_empty:
  assumes "base_of S \<O>"
  shows "base_of S {U \<in> \<O>. U \<noteq> {}}"
  unfolding base_of_def2'
proof safe
  fix x
  assume "x \<in> \<O>" " \<not> openin S x"
  thus "\<And>y. y \<in> {}"
    using base_of_openin[OF assms \<open>x \<in> \<O>\<close>] by simp
next
  fix x
  assume "openin S x"
  then obtain B' where "B' \<subseteq>\<O>" "\<Union> B' = x"
    using assms by(simp add: base_of_def2') metis
  thus "\<exists>B'\<subseteq>{U \<in> \<O>. U \<noteq> {}}. \<Union> B' = x"
    by(auto intro!: exI[where x="{y \<in> B'. y \<noteq> {}}"])
qed

lemma second_countable_ex_without_empty:
  assumes "second_countable S"
  shows "\<exists>\<O>. countable \<O> \<and> base_of S \<O> \<and> (\<forall>U\<in>\<O>. U \<noteq> {})"
proof -
  obtain \<O> where "countable \<O>" "base_of S \<O>"
    using assms second_countable_def by blast
  thus ?thesis
    by(auto intro!: exI[where x="{U \<in> \<O>. U \<noteq> {}}"] base_of_without_empty)
qed

lemma subtopology_subbase_of:
  assumes "subbase_of S \<O>"
  shows "subbase_of (subtopology S T) {T \<inter> U | U. U \<in> \<O>}"
  using assms subtopology_generated_by
  by(auto simp: subbase_of_def)

lemma subtopology_base_of:
  assumes "base_of S \<O>"
  shows "base_of (subtopology S T) {T \<inter> U | U. U \<in> \<O>}"
  unfolding base_of_def
proof
  fix L
  show "openin (subtopology S T) L = (\<exists>\<U>. L = \<Union> \<U> \<and> \<U> \<subseteq> {T \<inter> U |U. U \<in> \<O>})"
  proof
    assume "openin (subtopology S T) L "
    then obtain T' where ht:
       "openin S T'" "L = T' \<inter> T"
      by(auto simp: openin_subtopology)
    then obtain \<U> where hu:
      "T' = (\<Union> \<U>)" "\<U> \<subseteq> \<O>"
      using assms by(auto simp: base_of_def)
    show "\<exists>\<U>. L = \<Union> \<U> \<and> \<U> \<subseteq> {T \<inter> U |U. U \<in> \<O>}"
      using hu ht by(auto intro!: exI[where x="{T \<inter> U | U. U \<in> \<U>}"])
  next
    assume "\<exists>\<U>. L = \<Union> \<U> \<and> \<U> \<subseteq> {T \<inter> U |U. U \<in> \<O>}"
    then obtain \<U> where hu: "L = \<Union> \<U>" "\<U> \<subseteq> {T \<inter> U |U. U \<in> \<O>}"
      by auto
    hence "\<forall>U\<in>\<U>. \<exists>U'\<in>\<O>. U = T \<inter> U'" by blast
    then obtain k where hk:"\<And>U. U \<in> \<U> \<Longrightarrow> k U \<in> \<O>" "\<And>U. U \<in> \<U> \<Longrightarrow> U = T \<inter> k U"
      by metis
    hence "L =  \<Union> {T \<inter> k U |U. U \<in> \<U>}" 
      using hu by auto
    also have "... = \<Union> {k U |U. U \<in> \<U>} \<inter> T" by auto
    finally have 1:"L = \<Union> {k U |U. U \<in> \<U>} \<inter> T" .
    moreover have "openin S (\<Union> {k U |U. U \<in> \<U>})"
      using hu hk assms by(auto simp: base_of_def)
    ultimately show "openin (subtopology S T) L"
      by(auto intro!: exI[where x="\<Union> {k U |U. U \<in> \<U>}"] simp: openin_subtopology)
  qed
qed

lemma second_countable_subtopology:
  assumes "second_countable S"
  shows "second_countable (subtopology S T)"
proof -
  obtain \<O> where "countable \<O>" "base_of S \<O>"
    using assms second_countable_def by blast
  thus ?thesis
    by(auto intro!: exI[where x="{T \<inter> U | U. U \<in> \<O>}"] simp: second_countable_def Setcompr_eq_image dest: subtopology_base_of)
qed

lemma Lindelof_of:
  assumes "second_countable S" "\<And>u. u \<in> U \<Longrightarrow> openin S u" "\<Union> U = topspace S"
  shows "\<exists>U'. countable U' \<and> U' \<subseteq> U \<and> \<Union> U' = topspace S"
proof -
  from assms(1) obtain \<O> where h: "countable \<O>" "base_of S \<O>"
    by(auto simp: second_countable_def)
  define B' where "B' \<equiv> {v\<in>\<O>. \<exists>u\<in>U. v \<subseteq> u}"
  have B': "countable B'"
    using h(1) by(auto simp: B'_def)
  have "\<forall>v. v \<in> B' \<longrightarrow> (\<exists>u\<in>U. v \<subseteq> u)" by(auto simp: B'_def)
  then obtain U' where U':"\<And>v. v \<in> B' \<Longrightarrow> U' v \<in> U" "\<And>v. v \<in> B' \<Longrightarrow> v \<subseteq> U' v"
    by metis
  show ?thesis
  proof(rule exI[where x="U' ` B'"])
    show "countable (U' ` B') \<and> U' ` B' \<subseteq> U \<and> \<Union> (U' ` B') = topspace S"
    proof safe
      fix x
      assume "x \<in> topspace S"
      then obtain u where u:"x \<in> u" "u \<in> U"
        using assms(3) by auto
      obtain v where v:"x \<in> v" "v \<in> \<O>" "v \<subseteq> u"
        using base_of_in_subset[OF h(2) assms(2)[OF u(2)] u(1)] by auto      
      show "x \<in> \<Union> (U' ` B')"
        using u v U' by(auto intro!: bexI[where x=v]) (auto simp: B'_def intro!: exI[where x=u])
    qed(use B' U' assms(2) openin_subset in blast)+
  qed
qed

lemma open_map_with_base:
  assumes "base_of S \<O>" "\<And>A. A \<in> \<O> \<Longrightarrow> openin S' (f ` A)"
  shows "open_map S S' f"
  unfolding open_map_def
proof safe
  fix U
  assume "openin S U"
  then obtain \<U> where "U = \<Union>\<U>" "\<U> \<subseteq> \<O>"
    using assms(1) by(auto simp: base_of_def)
  hence "f ` U = \<Union>{ f ` A | A. A \<in> \<U>}" by blast
  also have "openin S' ..."
    using assms(2) \<open>\<U> \<subseteq> \<O>\<close> by auto
  finally show "openin S' (f ` U)" .
qed

text \<open> Construct a base from a subbase.\<close>
definition finite_intersections :: "'a set set \<Rightarrow> 'a set set" where
"finite_intersections \<O> \<equiv> { \<Inter>\<O>' | \<O>'. \<O>' \<noteq> {} \<and> finite \<O>' \<and> \<O>' \<subseteq> \<O>}"

lemma finite_intersections_inI:
  assumes "U = \<Inter>\<O>'" "\<O>' \<noteq> {}" " finite \<O>'" and "\<O>' \<subseteq> \<O>"
  shows "U \<in> finite_intersections \<O>"
  using assms by(auto simp: finite_intersections_def)

lemma finite_intersections_Uin:
  assumes "U \<in> \<O>"
  shows "U \<in> finite_intersections \<O>"
  using assms by(auto intro!: finite_intersections_inI[of U "{U}"])

lemma finite_intersections_int:
  assumes "U \<in> finite_intersections \<O>" and "V \<in> finite_intersections \<O>"
  shows "U \<inter> V \<in> finite_intersections \<O>"
proof -
  obtain \<O>U \<O>V where
   "U = \<Inter>\<O>U" "\<O>U \<noteq> {}" "finite \<O>U" "\<O>U \<subseteq> \<O>" "V = \<Inter>\<O>V" "finite \<O>V" "\<O>V \<subseteq> \<O>"
    using assms by(auto simp: finite_intersections_def)
  thus ?thesis
    by(auto intro!: finite_intersections_inI[of _ "\<O>U \<union> \<O>V"])
qed

lemma finite_intersections_countable:
  assumes "countable \<O>"
  shows "countable (finite_intersections \<O>)"
proof -
  have "finite_intersections \<O> = (\<Union>i\<in>{\<O>'. \<O>' \<noteq> {} \<and> finite \<O>' \<and> \<O>' \<subseteq> \<O>}. {\<Inter> i})"
    by(auto simp: finite_intersections_def)
  also have "countable ..."
    using  countable_Collect_finite_subset[OF assms] 
    by(auto intro!: countable_UN[of "{ \<O>'. \<O>' \<noteq> {} \<and> finite \<O>' \<and> \<O>' \<subseteq> \<O>}" "\<lambda>\<O>'. {\<Inter>\<O>'}"])
      (auto intro!: countable_subset[of "{\<O>'. \<O>' \<noteq> {} \<and> finite \<O>' \<and> \<O>' \<subseteq> \<O>}" "{A. finite A \<and> A \<subseteq> \<O>}"])
  finally show ?thesis .
qed

lemma finite_intersections_openin:
  assumes "U \<in> finite_intersections \<O>"
  shows "openin (topology_generated_by \<O>) U"
proof -
  obtain \<O>U where hu:
   "U = \<Inter>\<O>U" "\<O>U \<noteq> {}" "finite \<O>U" "\<O>U \<subseteq> \<O>"
    using assms by(auto simp: finite_intersections_def)
  show ?thesis
    using hu by(auto intro: topology_generated_by_Basis)
qed

lemma topology_generated_by_finite_intersections:
 "topology_generated_by \<O> = topology_generated_by (finite_intersections \<O>)"
proof(rule topology_generated_by_eq)
  fix U
  assume "U \<in> \<O>"
  then show "openin (topology_generated_by (finite_intersections \<O>)) U"
    by(auto intro!: topology_generated_by_Basis simp: finite_intersections_Uin)
qed (rule finite_intersections_openin)

lemma topology_generated_by_is_union_of_finite_intersections:
 "openin (topology_generated_by \<O>) U \<longleftrightarrow> (\<exists>\<U>. U = \<Union>\<U> \<and> \<U> \<subseteq> finite_intersections \<O>)"
proof
  assume "openin (topology_generated_by \<O>) U"
  then have "generate_topology_on \<O> U"
    by (simp add: openin_topology_generated_by_iff)
  thus "\<exists>\<U>. U = \<Union> \<U> \<and> \<U> \<subseteq> finite_intersections \<O>"
  proof induction
    case Empty
    then show ?case
      by auto
  next
    case (Int a b)
    then obtain \<U>a \<U>b where hab:
     "a = \<Union> \<U>a" "\<U>a \<subseteq> finite_intersections \<O>" "b = \<Union> \<U>b" "\<U>b \<subseteq> finite_intersections \<O>"
      by auto
    then have "a \<inter> b = \<Union>{ Ua \<inter> Ub | Ua Ub. Ua \<in> \<U>a \<and> Ub \<in> \<U>b}"
      by blast
    moreover have "{ Ua \<inter> Ub | Ua Ub. Ua \<in> \<U>a \<and> Ub \<in> \<U>b} \<subseteq> finite_intersections \<O>"
      using hab(2,4) finite_intersections_int by blast
    ultimately show ?case by auto
  next
    case (UN K)
    then have "\<exists>\<U>. \<forall>k\<in>K. k = \<Union> (\<U> k) \<and> \<U> k \<subseteq> finite_intersections \<O>"
      by(auto intro!: bchoice)
    then obtain \<U> where
     "\<forall>k\<in>K. k = \<Union> (\<U> k) \<and> \<U> k \<subseteq> finite_intersections \<O>" by auto
    thus ?case
      by(auto intro!: exI[where x="\<Union>k\<in>K. (\<U> k)"]) (metis UnionE)
  next
    case (Basis s)
    then show ?case
      by(auto intro!: exI[where x="{s}"] finite_intersections_Uin)
  qed
next
  assume "\<exists>\<U>. U = \<Union> \<U> \<and> \<U> \<subseteq> finite_intersections \<O>"
  then obtain \<U> where
   "U = \<Union> \<U>" "\<U> \<subseteq> finite_intersections \<O>" by auto
  thus "openin (topology_generated_by \<O>) U"
    using finite_intersections_openin
    by(auto simp: openin_topology_generated_by_iff intro!:  generate_topology_on.UN)
qed

lemma base_from_subbase:
  assumes "subbase_of S \<O>"
  shows "base_of S (finite_intersections \<O>)"
  using topology_generated_by_is_union_of_finite_intersections[of \<O>,simplified assms[simplified subbase_of_def,symmetric]]
  by(simp add: base_of_def)

lemma countable_base_from_countable_subbase:
  assumes "countable \<O>" and "subbase_of S \<O>"
  shows "second_countable S"
  using finite_intersections_countable[OF assms(1)] base_from_subbase[OF assms(2)]
  by(auto simp: second_countable_def)

lemma prod_topology_second_countable:
  assumes "second_countable S" and "second_countable S'"
  shows "second_countable (prod_topology S S')"
proof -
  obtain \<O> \<O>' where ho:
   "countable \<O>" "base_of S \<O>" "countable \<O>'" "base_of S' \<O>'"
    using assms by(auto simp: second_countable_def)
  show ?thesis
  proof(rule countable_base_from_countable_subbase[where \<O>="{ U \<times> V | U V. U \<in> \<O> \<and> V \<in> \<O>'}"])
    have "{U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<O>'} = (\<lambda>(U,V). U \<times> V) ` (\<O> \<times> \<O>')"
      by auto
    also have "countable ..."
      using ho(1,3) by auto
    finally show "countable {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<O>'}" .
  next
    show "subbase_of (prod_topology S S') {U \<times> V |U V. U \<in> \<O> \<and> V \<in> \<O>'}"
      using base_is_subbase[OF ho(2)] base_is_subbase[OF ho(4)]
      by(simp add: subbase_of_def prod_topology_generated_by)
  qed
qed

text \<open> Abstract version of the theorem @{thm product_topology_countable_basis}.\<close>
lemma product_topology_countable_base_of:
  assumes "countable I" and "\<And>i. i \<in> I \<Longrightarrow> second_countable (S i)"
  shows "\<exists>\<O>'. countable \<O>' \<and> base_of (product_topology S I) \<O>' \<and>
             (\<forall>k \<in> \<O>'. \<exists>X. k = (\<Pi>\<^sub>E i\<in>I. X i) \<and> (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)} \<and> {i. X i \<noteq> topspace (S i)} \<subseteq> I)"
proof -
  obtain \<O> where ho:
  "\<And>i. i \<in> I \<Longrightarrow> countable (\<O> i)" "\<And>i. i \<in> I \<Longrightarrow> base_of (S i) (\<O> i)"
    using assms(2)[simplified second_countable_def] by metis
  show ?thesis
    unfolding second_countable_def
  proof(intro exI[where x="{\<Pi>\<^sub>E i\<in>I. U i | U. finite {i\<in>I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i\<in>I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)}"] conjI)
    show "countable {\<Pi>\<^sub>E i\<in>I. U i | U. finite {i\<in>I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i\<in>I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)}"
         (is "countable ?X")
    proof -
      have "?X  = {\<Pi>\<^sub>E i\<in>I. U i | U. finite {i\<in>I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i\<in>I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i \<in>(UNIV- I). U i = {undefined})}"
           (is "_ = ?Y")
      proof (rule set_eqI)
        show "\<And>x. x \<in> ?X \<longleftrightarrow> x \<in> ?Y"
        proof
          fix x
          assume "x \<in> ?X"
          then obtain U where hu:
         "x = (\<Pi>\<^sub>E i\<in>I. U i)" "finite {i\<in>I. U i \<noteq> topspace (S i)}" "(\<forall>i\<in>{i\<in>I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)"
            by auto
          define U' where "U' i \<equiv> (if i \<in> I then U i else {undefined})" for i
          have "x = (\<Pi>\<^sub>E i\<in>I. U' i)"
            using hu(1) by(auto simp: U'_def PiE_def extensional_def Pi_def)
          moreover have "finite {i\<in>I. U' i \<noteq> topspace (S i)}" "(\<forall>i\<in>{i\<in>I. U' i \<noteq> topspace (S i)}. U' i \<in> \<O> i)" "\<forall>i \<in>(UNIV- I). U' i = {undefined}"
            using hu(2,3) by(auto simp: U'_def) (metis (mono_tags, lifting) Collect_cong)
          ultimately show "x \<in> ?Y" by auto
        qed auto
      qed
      also have "... = (\<lambda>U. \<Pi>\<^sub>E i\<in>I. U i) ` {U. finite {i\<in>I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i\<in>I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i \<in>(UNIV- I). U i = {undefined})}" by auto
      also have "countable ..."
      proof(rule countable_image)
        have "{U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})} = {U. \<exists>I'. finite I' \<and> I' \<subseteq> I \<and> (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>(I - I'). U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
            (is "?A = ?B")
        proof (rule set_eqI)
          show "\<And>x. x \<in> ?A \<longleftrightarrow> x \<in> ?B"
          proof
            fix U
            assume "U \<in> {U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
            then show "U \<in> {U. \<exists>I'. finite I' \<and> I' \<subseteq> I \<and> (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
              by auto
          next
            fix U
            assume assm:"U \<in> {U. \<exists>I'. finite I' \<and> I' \<subseteq> I \<and> (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
            then obtain I' where hi':
               "finite I'" "I' \<subseteq> I" "\<forall>i\<in>I'. U i \<in> \<O> i" "\<forall>i\<in>I - I'. U i = topspace (S i)" "\<forall>i\<in>UNIV - I. U i = {undefined}"
              by auto
            then have "\<And>i. i \<in> I \<Longrightarrow> U i \<noteq> topspace (S i) \<Longrightarrow> i \<in> I'" by auto
            hence "{i \<in> I. U i \<noteq> topspace (S i)} \<subseteq> I'" by auto
            hence "finite {i \<in> I. U i \<noteq> topspace (S i)}"
              using hi'(1) by (simp add: rev_finite_subset) 
            thus "U \<in> {U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
              using hi' by auto
          qed
        qed
        also have "... = (\<Union>I'\<in>{I'. finite I' \<and> I' \<subseteq> I}. {U. (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})})"
          by auto
        also have "countable ..."
        proof(rule countable_UN[OF countable_Collect_finite_subset[OF assms(1)]])
          fix I'
          assume "I' \<in> {I'. finite I' \<and> I' \<subseteq> I}"
          hence hi':"finite I'" "I' \<subseteq> I" by auto
          have "(\<lambda>U i. if i \<in> I' then U i else undefined) ` {U. (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})} \<subseteq> (\<Pi>\<^sub>E i\<in>I'. \<O> i)"
            by auto
          moreover have "countable ..."
            using hi' by(auto intro!: countable_PiE ho)
          ultimately have "countable ((\<lambda>U i. if i \<in> I' then U i else undefined) ` {U. (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})})"
            by(simp add: countable_subset)
          moreover have "inj_on (\<lambda>U i. if i \<in> I' then U i else undefined) {U. (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
                        (is "inj_on ?f ?X")
          proof
            fix x y
            assume hxy: "x \<in> ?X" "y \<in> ?X" "?f x = ?f y"
            show "x = y"
            proof
              fix i
              consider "i \<in> I'" | "i \<in> I - I'" | "i \<in> UNIV - I"
                using hi'(2) by blast
              then show "x i = y i"
              proof cases
                case i:1
                then show ?thesis
                  using fun_cong[OF hxy(3),of i] by auto
              next
                case i:2
                then show ?thesis
                  using hxy(1,2) by auto
              next
                case i:3
                then show ?thesis
                  using hxy(1,2) by auto
              qed
            qed
          qed
          ultimately show "countable {U. (\<forall>i\<in>I'. U i \<in> \<O> i) \<and> (\<forall>i\<in>I - I'. U i = topspace (S i)) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}"
            using countable_image_inj_on by auto
        qed
        finally show "countable {U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i) \<and> (\<forall>i\<in>UNIV - I. U i = {undefined})}" .
      qed
      finally show ?thesis .
    qed
  next
    show "base_of (product_topology S I) {\<Pi>\<^sub>E i\<in>I. U i |U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)}"
         (is "base_of (product_topology S I) ?X")
      unfolding base_of_def
    proof safe
      fix U
      assume "openin (product_topology S I) U"
      then have "\<forall>x\<in>U. \<exists>Ux. finite {i \<in> I. Ux i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>I. openin (S i) (Ux i)) \<and> x \<in> Pi\<^sub>E I Ux \<and> Pi\<^sub>E I Ux \<subseteq> U"
        by(simp add: openin_product_topology_alt)
      hence "\<exists>Ux. \<forall>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>I. openin (S i) (Ux x i)) \<and> x \<in> Pi\<^sub>E I (Ux x) \<and> Pi\<^sub>E I (Ux x) \<subseteq> U"
        by(rule bchoice)
      then obtain Ux where hui:
       "\<And>x. x \<in> U \<Longrightarrow> finite {i \<in> I. Ux x i \<noteq> topspace (S i)}" "\<And>x i. x \<in> U \<Longrightarrow> i \<in> I \<Longrightarrow> openin (S i) (Ux x i)" "\<And>x. x \<in> U \<Longrightarrow> x \<in> Pi\<^sub>E I (Ux x)" "\<And>x. x \<in> U \<Longrightarrow> Pi\<^sub>E I (Ux x) \<subseteq> U"
        by fastforce
      then have 1:"\<forall>x\<in>U. \<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. \<exists>\<U>xj. \<U>xj \<subseteq> \<O> i \<and> Ux x i = \<Union> \<U>xj"
        using ho[simplified base_of_def] by (metis (no_types, lifting) mem_Collect_eq) 
      have "\<forall>x\<in>U. \<exists>\<U>xj. \<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. \<U>xj i \<subseteq> \<O> i \<and> Ux x i = \<Union> (\<U>xj i)"
        by(standard, rule bchoice) (use 1 in simp)
      hence "\<exists>\<U>xj. \<forall>x\<in>U. \<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. \<U>xj x i \<subseteq> \<O> i \<and> Ux x i = \<Union> (\<U>xj x i)"
        by(rule bchoice)
      then obtain \<U>xj where
       "\<forall>x\<in>U. \<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. \<U>xj x i \<subseteq> \<O> i \<and> Ux x i = \<Union> (\<U>xj x i)"
        by auto
      hence huxj: "\<And>x i. x \<in> U \<Longrightarrow> i \<in> {i \<in> I. Ux x i \<noteq> topspace (S i)} \<Longrightarrow> \<U>xj x i \<subseteq> \<O> i"
                  "\<And>x i. x \<in> U \<Longrightarrow> i \<in> {i \<in> I. Ux x i \<noteq> topspace (S i)} \<Longrightarrow> Ux x i = \<Union> (\<U>xj x i)"
        by blast+
      show "\<exists>\<U>. U = \<Union> \<U> \<and> \<U> \<subseteq> ?X"
      proof(intro exI[where x="{\<Pi>\<^sub>E i\<in>I. K i | K. \<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))}"] conjI)
        show "U = \<Union> {\<Pi>\<^sub>E i\<in>I. K i | K. \<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))}"
        proof safe
          fix x
          assume hxu:"x \<in> U"
          have "\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. Ux x i = \<Union> (\<U>xj x i)"
            using huxj[OF hxu] by blast
          hence "\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. \<exists>Uxj. Uxj \<in> \<U>xj x i \<and> x i \<in> Uxj"
            using hui(3)[OF hxu] by auto
          hence "\<exists>Uxj. \<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. Uxj i \<in> \<U>xj x i \<and> x i \<in> Uxj i"
            by(rule bchoice)
          then obtain Uxj where huxj':
             "\<And>i. i \<in> {i \<in> I. Ux x i \<noteq> topspace (S i)} \<Longrightarrow> Uxj i \<in> \<U>xj x i"
             "\<And>i. i \<in> {i \<in> I. Ux x i \<noteq> topspace (S i)} \<Longrightarrow> x i \<in> Uxj i"
            by auto
          define K where "K \<equiv> (\<lambda>i. if i \<in> {i \<in> I. Ux x i \<noteq> topspace (S i)} then Uxj i else topspace (S i))"
          have "x \<in> (\<Pi>\<^sub>E i\<in>I. K i)"
            using huxj'(2) hui(3,4)[OF hxu] openin_subset[OF hui(2)[OF hxu]]
            by(auto simp: K_def PiE_def Pi_def)
          moreover have "\<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))"
            by(rule bexI[OF _ hxu], rule conjI,simp add: hui(1)[OF hxu]) (use hui(2) hxu openin_subset huxj'(1)  K_def in auto)
          ultimately show "x \<in> \<Union> {\<Pi>\<^sub>E i\<in>I. K i | K. \<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))}"
            by auto
        next
          fix x X K u
          assume  hu: "x \<in> (\<Pi>\<^sub>E i\<in>I. K i)"  "u \<in> U" "finite {i \<in> I. Ux u i \<noteq> topspace (S i)}" "\<forall>i\<in>{i \<in> I. Ux u i \<noteq> topspace (S i)}. K i \<in> \<U>xj u i" "\<forall>i\<in>UNIV -{i \<in> I. Ux u i \<noteq> topspace (S i)}. K i = topspace (S i)"            
          have "\<And>i. i \<in> {i \<in> I. Ux u i \<noteq> topspace (S i)} \<Longrightarrow> K i \<subseteq> Ux u i"
            using huxj[OF hu(2)] hu(4) by blast
          moreover have "\<And>i. i \<in> I - {i \<in> I. Ux u i \<noteq> topspace (S i)} \<Longrightarrow> K i = Ux u i"
            using hu(5) by auto
          ultimately have "\<And>i. i \<in> I \<Longrightarrow> K i \<subseteq> Ux u i"
            by blast
          thus "x \<in> U"
            using hui(4)[OF hu(2)] hu(1) by blast
        qed
      next
        show "{\<Pi>\<^sub>E i\<in>I. K i | K. \<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))} \<subseteq> ?X"
        proof
          fix x
          assume "x \<in> {\<Pi>\<^sub>E i\<in>I. K i | K. \<exists>x\<in>U. finite {i \<in> I. Ux x i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i \<in> \<U>xj x i) \<and> (\<forall>i\<in>UNIV -{i \<in> I. Ux x i \<noteq> topspace (S i)}. K i = topspace (S i))}"
          then obtain u K where hu:
           "x = (\<Pi>\<^sub>E i\<in>I. K i)"  "u \<in> U" "finite {i \<in> I. Ux u i \<noteq> topspace (S i)}" "\<forall>i\<in>{i \<in> I. Ux u i \<noteq> topspace (S i)}. K i \<in> \<U>xj u i" "\<forall>i\<in>UNIV -{i \<in> I. Ux u i \<noteq> topspace (S i)}. K i = topspace (S i)"
            by auto
          have hksubst:"{i \<in> I. K i \<noteq> topspace (S i)} \<subseteq> {i \<in> I. Ux u i \<noteq> topspace (S i)}"
            using hu(5) by fastforce
          hence "finite {i \<in> I. K i \<noteq> topspace (S i)}"
            using hu(3) by (simp add: finite_subset)
          moreover have "\<forall>i\<in>{i \<in> I. K i \<noteq> topspace (S i)}. K i \<in> \<O> i"
            using huxj(1)[OF hu(2)] hu(4) hksubst
            by (meson subsetD)
          ultimately show "x \<in> ?X"
            using hu(1) by auto
        qed
      qed
    next
      fix \<U>
      assume "\<U> \<subseteq> ?X"
      have "openin (product_topology S I) u" if hu:"u \<in> \<U>" for u
      proof -
        have hu': "u \<in> ?X"
          using \<open>\<U> \<subseteq> ?X\<close> hu by auto
        then obtain U where hU:
       "u = (\<Pi>\<^sub>E i\<in>I. U i)" "finite {i \<in> I. U i \<noteq> topspace (S i)}" "\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i"
          by auto
        define U' where "U' \<equiv> (\<lambda>i. if i \<in> {i \<in> I. U i \<noteq> topspace (S i)} then U i else topspace (S i))"
        have hU': "u = (\<Pi>\<^sub>E i\<in>I. U' i)"
          by(auto simp: hU(1) U'_def PiE_def Pi_def)
        have hUfinite : "finite {i. U' i \<noteq> topspace (S i)}"
          using hU(2) by(auto simp: U'_def)
        have hUoi: "\<forall>i\<in>{i. U' i \<noteq> topspace (S i)}. U' i \<in> \<O> i"
          using hU(3) by(auto simp: U'_def)
        have hUi: "\<forall>i\<in>{i. U' i \<noteq> topspace (S i)}. i \<in> I"
          using hU(2) by(auto simp: U'_def)
        have hallopen:"openin (S i) (U' i)" for i
        proof -
          consider "i \<in> {i. U' i \<noteq> topspace (S i)}" | "i \<notin> {i. U' i \<noteq> topspace (S i)}" by auto
          then show ?thesis
          proof cases
            case 1
            then show ?thesis
              using hUoi ho(2)[of i] base_of_openin[of "S i" "\<O> i" "U' i"] hUi
              by auto
          next
            case 2
            then have "U' i = topspace (S i)" by auto
            thus ?thesis by auto
          qed
        qed
        show "openin (product_topology S I) u"
          using hallopen hUfinite by(auto intro!: product_topology_basis simp: hU')
      qed
      thus "openin (product_topology S I) (\<Union> \<U>)"
        by auto
    qed
  next
    show "\<forall>k\<in>{Pi\<^sub>E I U |U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)}. \<exists>X. k = Pi\<^sub>E I X \<and> (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)} \<and> {i. X i \<noteq> topspace (S i)} \<subseteq> I"
    proof
      fix k
      assume "k \<in> {Pi\<^sub>E I U |U. finite {i \<in> I. U i \<noteq> topspace (S i)} \<and> (\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i)}"
      then obtain U where hu:
         "k = (\<Pi>\<^sub>E i\<in>I. U i)" "finite {i \<in> I. U i \<noteq> topspace (S i)}" "\<forall>i\<in>{i \<in> I. U i \<noteq> topspace (S i)}. U i \<in> \<O> i"
        by auto
      define X where "X \<equiv> (\<lambda>i. if i \<in> {i \<in> I. U i \<noteq> topspace (S i)} then U i else topspace (S i))"
      have hX1: "k = (\<Pi>\<^sub>E i\<in>I. X i)"
        using hu(1) by(auto simp: X_def PiE_def Pi_def)
      have hX2: "openin (S i) (X i)" for i
        using hu(3) base_of_openin[of "S i" _ "U i",OF ho(2)]
        by(auto simp: X_def)
      have hX3: "finite {i. X i \<noteq> topspace (S i)}"
        using hu(2) by(auto simp: X_def)
      have hX4: "{i. X i \<noteq> topspace (S i)} \<subseteq> I"
        by(auto simp: X_def)
      show "\<exists>X. k = (\<Pi>\<^sub>E i\<in>I. X i) \<and> (\<forall>i. openin (S i) (X i)) \<and> finite {i. X i \<noteq> topspace (S i)} \<and> {i. X i \<noteq> topspace (S i)} \<subseteq> I"
        using hX1 hX2 hX3 hX4 by(auto intro!: exI[where x=X])
    qed
  qed
qed

lemma product_topology_second_countable:
  assumes "countable I" and "\<And>i. i \<in> I \<Longrightarrow> second_countable (S i)"
  shows "second_countable (product_topology S I)"
  using product_topology_countable_base_of[OF assms(1)] assms(2)
  by(fastforce simp: second_countable_def)

lemma Cantor_Bendixon:
  assumes "second_countable X"
  shows "\<exists>U P. countable U \<and> openin X U \<and> perfect_set X P \<and> U \<union> P = topspace X \<and> U \<inter> P = {} \<and> (\<forall>a\<noteq>{}. openin (subtopology X P) a \<longrightarrow> uncountable a)"
proof -
  obtain \<O> where o: "countable \<O>" "base_of X \<O>"
    using assms by(auto simp: second_countable_def)
  define U where "U \<equiv> \<Union> {u\<in>\<O>. countable u}"
  define P where "P \<equiv> topspace X - U"
  have 1: "countable U"
    using o(1) by(auto simp: U_def intro!: countable_UN[of _ id,simplified])
  have 2: "openin X U"
    using base_of_openin[OF o(2)] by(auto simp: U_def)
  have openin_c:"countable v \<longleftrightarrow> v \<subseteq> U" if "openin X v" for v
  proof
    assume "countable v"
    obtain \<U> where "v = \<Union>\<U>" "\<U> \<subseteq> \<O>"
      using \<open>openin X v\<close> o(2) by(auto simp: base_of_def)
    with \<open>countable v\<close> have "\<And>u. u \<in> \<U> \<Longrightarrow> countable u"
      by (meson Sup_upper countable_subset)
    thus "v \<subseteq> U"
      using \<open>\<U> \<subseteq> \<O>\<close> by(auto simp: \<open>v = \<Union>\<U>\<close> U_def)
  qed(rule countable_subset[OF _ 1])
  have 3: "perfect_set X P"
  proof(rule perfect_setI)
    fix x T
    assume h:"x \<in> P" "x \<in> T" "openin X T"
    have T_unc:"uncountable T"
      using openin_c[OF h(3)] h(1,2) by(auto simp: P_def)
    obtain \<U> where U:"T = \<Union>\<U>" "\<U> \<subseteq> \<O>"
      using h(3) o(2) by(auto simp: base_of_def)
    then obtain u where u:"u \<in> \<U>" "uncountable u"
      using T_unc U_def h(3) openin_c by auto
    hence "uncountable (u - {x})" by simp
    hence "\<not> (u - {x} \<subseteq> U)"
      using 1 by (metis countable_subset) 
    then obtain y where "y \<in> u - {x}" "y \<notin> U"
      by blast
    thus "\<exists>y. y \<noteq> x \<and> y \<in> T \<and> y \<in> P"
      using U u base_of_subset[OF o(2),of u] by(auto intro!: exI[where x=y] simp:P_def)
  qed(use 2 P_def in auto)
  have 4 : "uncountable a" if "openin (subtopology X P) a" "a \<noteq> {}" for a
  proof
    assume contable:"countable a"
    obtain b where b: "openin X b" "a = P \<inter> b"
      using \<open>openin (subtopology X P) a\<close> by(auto simp: openin_subtopology)
    hence "uncountable b"
      using P_def openin_c that(2) by auto
    thus False
      by (metis 1 Diff_Int_distrib2 Int_absorb1 P_def b(1) b(2) contable countable_Int1 openin_subset uncountable_minus_countable)
  qed
  show ?thesis
    using 1 2 3 4 by(auto simp: P_def)
qed

subsubsection \<open> Dense and Separable in Abstract Topology\<close>
definition dense_of :: "['a topology, 'a set] \<Rightarrow> bool" where
"dense_of S U \<longleftrightarrow> (U \<subseteq> topspace S \<and> (\<forall>V. openin S V \<longrightarrow> V \<noteq> {} \<longrightarrow> U \<inter> V \<noteq> {}))"

lemma dense_of_def2:
 "dense_of S U \<longleftrightarrow> (U \<subseteq> topspace S \<and> (S closure_of U) = topspace S)"
  using dense_intersects_open by(auto simp: dense_of_def closure_of_subset_topspace in_closure_of) auto

lemma dense_of_subset:
  assumes "dense_of S U"
  shows "U \<subseteq> topspace S"
  using assms by(simp add: dense_of_def)

lemma dense_of_nonempty:
  assumes "topspace S \<noteq> {}" "dense_of S U"
  shows "U \<noteq> {}"
  using assms by(auto simp: dense_of_def)

definition separable :: "'a topology \<Rightarrow> bool" where
"separable S \<longleftrightarrow> (\<exists>U. countable U \<and> dense_of S U)"

lemma dense_ofI:
  assumes "U \<subseteq> topspace S"
      and "\<And>V. openin S V \<Longrightarrow> V \<noteq> {} \<Longrightarrow> U \<inter> V \<noteq> {}"
    shows "dense_of S U"
  using assms by(auto simp: dense_of_def)

lemma separable_if_second_countable:
  assumes "second_countable S"
  shows "separable S"
proof -
  obtain \<O> where ho:
    "countable \<O>" "base_of S \<O>" "\<And>u. u \<in> \<O> \<Longrightarrow> u \<noteq> {}"
    using second_countable_ex_without_empty[OF assms] by auto
  then obtain x where hx: "\<And>u. u \<in> \<O> \<Longrightarrow> x u \<in> u"
    by (metis all_not_in_conv)
  show ?thesis
    unfolding separable_def
  proof(intro exI[where x="{x u|u. u \<in> \<O>}"] conjI)
    show "countable {x u |u. u \<in> \<O>}"
      using ho(1) by (simp add: Setcompr_eq_image)
  next
    show "dense_of S {x u |u. u \<in> \<O>}"
    proof(rule dense_ofI)
      show "{x u |u. u \<in> \<O>} \<subseteq> topspace S"
        using  hx base_of_subset[OF ho(2)] by auto
    next
      fix V
      assume "openin S V" "V \<noteq> {}"
      then obtain B where hb:"B \<subseteq> \<O>" "V = \<Union> B"
        using base_of_def2' ho(2) by metis
      with \<open>V \<noteq> {}\<close> obtain b where "b \<in> B"
        by auto
      hence "{x u |u. u \<in> \<O>} \<inter> b \<subseteq> {x u |u. u \<in> \<O>} \<inter> V"
        using hb(2) by auto
      moreover have "x b \<in> {x u |u. u \<in> \<O>} \<inter> b"
        using hb(1) \<open>b \<in> B\<close> hx[of b] by auto
      ultimately show "{x u |u. u \<in> \<O>} \<inter> V \<noteq> {}"
        by auto
    qed
  qed
qed

lemma dense_of_prod:
  assumes "dense_of S U" and "dense_of S' U'"
  shows "dense_of (prod_topology S S') (U \<times> U')"
proof(rule dense_ofI)
  fix V
  assume h:"openin (prod_topology S S') V" "V \<noteq> {}"
  then obtain x y where hxy:"(x,y) \<in> V" by auto
  then obtain V1 V2 where hv12:
  "openin S V1" "openin S' V2" "x \<in> V1" "y \<in> V2" "V1 \<times> V2 \<subseteq> V"
    using h(1) openin_prod_topology_alt[of S S' V] by blast
  hence "V1 \<noteq> {}" "V2 \<noteq> {}" by auto
  hence "U \<inter> V1 \<noteq> {}" "U' \<inter> V2 \<noteq> {}"
    using assms hv12 by(auto simp: dense_of_def)
  thus "U \<times> U' \<inter> V \<noteq> {}"
    using hv12 by auto
next
  show "U \<times> U' \<subseteq> topspace (prod_topology S S')"
    using assms by(auto simp add: dense_of_def)
qed

lemma separable_prod:
  assumes "separable S" and "separable S'"
  shows "separable (prod_topology S S')"
proof -
  obtain U U' where
    "countable U" "dense_of S U" "countable U'" "dense_of S' U'"
    using assms by(auto simp: separable_def)
  thus ?thesis
    by(auto intro!: exI[where x="U\<times>U'"] dense_of_prod simp: separable_def)
qed

lemma dense_of_product:
  assumes "\<And>i. i \<in> I \<Longrightarrow> dense_of (T i) (U i)"
  shows "dense_of (product_topology T I) (\<Pi>\<^sub>E i\<in>I. U i)"
proof(rule dense_ofI)
  fix V
  assume h:"openin (product_topology T I) V" "V \<noteq> {}"
  then obtain x where hx:"x \<in> V" by auto
  then obtain K where hk:
   "finite {i \<in> I. K i \<noteq> topspace (T i)}" "\<forall>i\<in>I. openin (T i) (K i)" "x \<in> (\<Pi>\<^sub>E i\<in>I. K i)" "(\<Pi>\<^sub>E i\<in>I. K i) \<subseteq> V"
    using h(1) openin_product_topology_alt[of T I V] by auto
  hence "\<And>i. i \<in> I \<Longrightarrow> K i \<noteq> {}" by auto
  hence "\<And>i. i \<in> I \<Longrightarrow> U i \<inter> K i \<noteq> {}"
    using assms hk by(auto simp: dense_of_def)
  hence "(\<Pi>\<^sub>E i\<in>I. U i) \<inter> (\<Pi>\<^sub>E i\<in>I. K i) \<noteq> {}"
    by (simp add: PiE_Int PiE_eq_empty_iff) 
  thus "(\<Pi>\<^sub>E i\<in>I. U i) \<inter> V \<noteq> {}"
    using hk by auto
next
  show "(\<Pi>\<^sub>E i\<in>I. U i) \<subseteq> topspace (product_topology T I)"
    using assms by(auto simp: dense_of_def)
qed

lemma separable_countable_product:
  assumes "countable I" and "\<And>i. i \<in> I \<Longrightarrow> separable (T i)"
  shows "separable (product_topology T I)"
proof -
  consider "\<exists>i\<in>I. topspace (T i) = {}" | "\<And>i. i \<in> I \<Longrightarrow> topspace (T i) \<noteq> {}"
    by auto
  thus ?thesis
  proof cases
    case 1
    then obtain i where i:"i \<in> I" "topspace (T i) = {}"
      by auto
    show ?thesis
      unfolding separable_def dense_of_def
    proof(intro exI[where x="{}"] conjI)
      show " \<forall>V. openin (product_topology T I) V \<longrightarrow> V \<noteq> {} \<longrightarrow> {} \<inter> V \<noteq> {}"
      proof safe
        fix V x
        assume h: "openin (product_topology T I) V" "x \<in> V"
        from i have "topspace (product_topology T I) = {}"
          by auto
        with h(1) have "V = {}"
          using openin_subset by blast
        thus "x \<in> {}"
          using h(2) by auto
      qed
    qed auto
  next
    case 2
    then have "\<exists>x. \<forall>i\<in>I. x i \<in> topspace (T i)"
      by (meson all_not_in_conv)
    moreover from "2"
    have "\<exists>U. \<forall>i\<in>I. countable (U i) \<and> dense_of (T i) (U i)"
      using assms(2) by(auto intro!: bchoice simp: separable_def)
    ultimately
    obtain x U where hxu:
     "\<And>i. i \<in> I \<Longrightarrow> x i \<in> topspace (T i)" "\<And>i. i \<in> I \<Longrightarrow> countable (U i)" "\<And>i. i \<in> I \<Longrightarrow> dense_of (T i) (U i)"
      by auto
    define U' where "U' \<equiv> (\<lambda>J i. if i \<in> J then U i else {x i})"
    show ?thesis
      unfolding separable_def
    proof(intro exI[where x="\<Union>{ \<Pi>\<^sub>E i\<in>I. U' J i | J. finite J \<and> J \<subseteq> I}"] conjI)
      have "(\<Union>{ \<Pi>\<^sub>E i\<in>I. U' J i | J. finite J \<and> J \<subseteq> I}) = (\<Union> ((\<lambda>J. \<Pi>\<^sub>E i\<in>I. U' J i) ` {J. finite J \<and> J \<subseteq> I}))"
        by auto
      also have "countable ..."
      proof(rule countable_UN)
        fix J
        assume hj:"J \<in> {J. finite J \<and> J \<subseteq> I}"
        have "inj_on (\<lambda>f. (\<lambda>i\<in>J. f i, \<lambda>i\<in>(I-J). f i)) (\<Pi>\<^sub>E i\<in>I. U' J i)"
        proof(rule inj_onI)
          fix f g
          assume h:"f \<in> Pi\<^sub>E I (U' J)" "g \<in> Pi\<^sub>E I (U' J)"
                   "(restrict f J, restrict f (I - J)) = (restrict g J, restrict g (I - J))"
          then have "\<And>i. i \<in> J \<Longrightarrow> f i = g i" "\<And>i. i \<in>(I-J) \<Longrightarrow> f i = g i"
             by(auto simp: restrict_def) meson+
          thus "f = g"
            using h(1,2) by(auto simp: U'_def) (meson PiE_ext)
        qed
        moreover have "countable ((\<lambda>f. (\<lambda>i\<in>J. f i, \<lambda>i\<in>(I-J). f i)) ` (\<Pi>\<^sub>E i\<in>I. U' J i))" (is "countable ?K")
        proof -
          have 1:"?K \<subseteq> (\<Pi>\<^sub>E i\<in>J. U i) \<times> (\<Pi>\<^sub>E i\<in>(I-J). {x i})"
            using hj by(auto simp: U'_def PiE_def Pi_def)
          have 2:"countable ..."
          proof(rule countable_SIGMA)
            show "countable (Pi\<^sub>E J U)"
              using hj hxu(2) by(auto intro!: countable_PiE)
          next
            have "(\<Pi>\<^sub>E i\<in>I - J. {x i}) = { \<lambda>i\<in>I-J. x i }"
              by(auto simp: PiE_def extensional_def restrict_def Pi_def)
            thus "countable (\<Pi>\<^sub>E i\<in>I - J. {x i})"
              by simp
          qed
          show ?thesis
            by(rule countable_subset[OF 1 2])
        qed
        ultimately show "countable (\<Pi>\<^sub>E i\<in>I. U' J i)"
          by(simp add: countable_image_inj_eq)
      qed(rule countable_Collect_finite_subset[OF assms(1)])
      finally show "countable (\<Union>{ \<Pi>\<^sub>E i\<in>I. U' J i | J. finite J \<and> J \<subseteq> I})" .
    next
      show "dense_of (product_topology T I) (\<Union> {\<Pi>\<^sub>E i\<in>I. U' J i |J. finite J \<and> J \<subseteq> I})"
      proof(rule dense_ofI)
        fix V
        assume h:"openin (product_topology T I) V" "V \<noteq> {}"
        then obtain y where hx:"y \<in> V" by auto
        then obtain K where hk:
         "finite {i \<in> I. K i \<noteq> topspace (T i)}" "\<And>i. i\<in>I \<Longrightarrow> openin (T i) (K i)" "y \<in> (\<Pi>\<^sub>E i\<in>I. K i)" "(\<Pi>\<^sub>E i\<in>I. K i) \<subseteq> V"
          using h(1) openin_product_topology_alt[of T I V] by auto
        hence 3:"\<And>i. i \<in> I \<Longrightarrow> K i \<noteq> {}" by auto
        hence 4:"i \<in> {i \<in> I. K i \<noteq> topspace (T i)} \<Longrightarrow> K i \<inter> U' {i \<in> I. K i \<noteq> topspace (T i)} i \<noteq> {}" for i
          using hxu(3)[of i] hk(2)[of i] by(auto simp: U'_def dense_of_def)
        have "\<exists>z. \<forall>i\<in>{i \<in> I. K i \<noteq> topspace (T i)}. z i \<in> K i \<inter> U' {i \<in> I. K i \<noteq> topspace (T i)} i"
          by(rule bchoice) (use 4 in auto)
        then obtain z where hz: "\<forall>i\<in>{i \<in> I. K i \<noteq> topspace (T i)}. z i \<in> K i \<inter> U' {i \<in> I. K i \<noteq> topspace (T i)} i"
          by auto          
        have 5: "i \<notin> {i \<in> I. K i \<noteq> topspace (T i)} \<Longrightarrow> i \<in> I \<Longrightarrow> x i \<in> K i" for i
          using hxu(1)[of i] by auto
        have "(\<lambda>i. if i \<in> {i \<in> I. K i \<noteq> topspace (T i)} then z i else if i \<in> I then x i else undefined) \<in> (\<Pi>\<^sub>E i\<in>I. U' {i \<in> I. K i \<noteq> topspace (T i)} i) \<inter> (\<Pi>\<^sub>E i\<in>I. K i)"
          using 4 5 hz by(auto simp: U'_def)
        thus "\<Union> {Pi\<^sub>E I (U' J) |J. finite J \<and> J \<subseteq> I} \<inter> V \<noteq> {}"
          using hk(1,4) by blast
      next
        have "\<And>J. J \<subseteq> I \<Longrightarrow> (\<Pi>\<^sub>E i\<in>I. U' J i) \<subseteq> topspace (product_topology T I)"
          using hxu by(auto simp: dense_of_def U'_def PiE_def Pi_def) (metis subsetD)
        thus "(\<Union> {\<Pi>\<^sub>E i\<in>I. U' J i |J. finite J \<and> J \<subseteq> I}) \<subseteq> topspace (product_topology T I)"
          by auto
      qed
    qed
  qed
qed

lemma separable_finite_product:
  assumes "finite I" and "\<And>i. i \<in> I \<Longrightarrow> separable (T i)"
  shows "separable (product_topology T I)"
  using separable_countable_product[OF countable_finite[OF assms(1)]] assms by auto

lemma homeomorphic_separable:
  assumes "separable X" "X homeomorphic_space Y"
  shows "separable Y"
proof -
  obtain f g where "homeomorphic_maps X Y f g"
    using assms(2) by(auto simp: homeomorphic_space_def)
  hence fg:"continuous_map X Y f" "continuous_map Y X g" "\<And>x. x \<in> topspace X \<Longrightarrow> g(f x) = x" "\<And>y. y \<in> topspace Y \<Longrightarrow> f(g y) = y"
    by(auto simp: homeomorphic_maps_def)
  obtain U where U: "countable U" "dense_of X U"
    using assms(1) by(auto simp: separable_def)
  show ?thesis
    unfolding separable_def dense_of_def countable_image[OF U(1)]
  proof(intro exI[where x="f ` U"] conjI)
    show "f ` U \<subseteq> topspace Y"
      using U(2) fg(1) by(auto simp: dense_of_def continuous_map_def)
  next
    show "\<forall>V. openin Y V \<longrightarrow> V \<noteq> {} \<longrightarrow> f ` U \<inter> V \<noteq> {}"
    proof safe
      fix V x
      assume h:"openin Y V" "f ` U \<inter> V = {}" "x \<in> V"
      then have "U \<inter> (f -` V \<inter> topspace X) = {}"
        by blast
      moreover have "f -` V \<inter> topspace X \<noteq> {}"
        using continuous_map_preimage_topspace fg(2) fg(4) h(1) h(3) openin_subset by fastforce
      moreover have "openin X (f -` V \<inter> topspace X)"
        using h(1) fg(1) by auto
      ultimately show "x \<in> {}"
        using U(2) by(auto simp: dense_of_def)
    qed
  qed(rule countable_image[OF U(1)])
qed

subsubsection \<open> $G_{\delta}$ Set in Abstract Topology\<close>
definition g_delta_of :: "['a topology, 'a set] \<Rightarrow> bool" where
"g_delta_of S A \<longleftrightarrow> (\<exists>\<U>. \<U> \<noteq> {} \<and> countable \<U> \<and> (\<forall>b\<in>\<U>. openin S b) \<and> A = \<Inter> \<U>)"

lemma g_delta_ofI:
  assumes "U \<noteq> {}" "countable U" "\<And>b. b \<in> U \<Longrightarrow> openin S b" "A = \<Inter> U"
  shows "g_delta_of S A"
  using assms by(auto simp: g_delta_of_def)

lemma g_delta_ofD:
  assumes "g_delta_of S A"
  shows "\<exists>\<U>. \<U> \<noteq> {} \<and> countable \<U> \<and> (\<forall>b\<in>\<U>. openin S b) \<and> A = \<Inter> \<U>"
  using assms by(simp add: g_delta_of_def)

lemma g_delta_ofD':
  assumes "g_delta_of S A"
  shows "\<exists>U. (\<forall>n::nat. openin S (U n)) \<and> A = \<Inter> (range U)"
proof-
  obtain \<U> where h:"\<U> \<noteq> {}" "countable \<U>" "\<And>b. b\<in>\<U> \<Longrightarrow> openin S b" "A = \<Inter> \<U>"
    using g_delta_ofD[OF assms] by metis
  show ?thesis
    using range_from_nat_into[OF h(1,2)] h(3,4)
    by(auto intro!: exI[where x="from_nat_into \<U>"])
qed

lemma g_delta_of_subset:
  assumes "g_delta_of S A"
  shows "A \<subseteq> topspace S"
  using assms openin_subset by(auto simp: g_delta_of_def)

lemma g_delta_of_open_set[simp]:
  assumes "openin S A"
  shows "g_delta_of S A"
  using assms by(auto simp: g_delta_of_def intro!: exI[where x="{A}"])

lemma g_delta_of_empty[simp]: "g_delta_of S {}"
  by simp

lemma g_delta_of_topspace[simp]: "g_delta_of S (topspace S)"
  by simp

lemma g_delta_of_inter:
  assumes "g_delta_of S A" and "g_delta_of S B"
  shows "g_delta_of S (A \<inter> B)"
proof -
  obtain Ua Ub where hu:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin S b" "A = \<Inter> Ua"
  "countable Ub" "\<And>b. b \<in> Ub \<Longrightarrow> openin S b" "B = \<Inter> Ub"
    using assms by(auto simp: g_delta_of_def)
  thus ?thesis
    by(auto intro!: g_delta_ofI[where U="Ua \<union> Ub"])
qed

lemma g_delta_of_Int:
  assumes "\<And>a. a \<in> \<U> \<Longrightarrow> g_delta_of X a" "countable \<U>" "\<U> \<noteq> {}"
  shows "g_delta_of X (\<Inter> \<U>)"
proof -
  obtain Ua where u:
  "\<And>a. a \<in> \<U> \<Longrightarrow> Ua a \<noteq> {}" "\<And>a. a \<in> \<U> \<Longrightarrow> countable (Ua a)" "\<And>a b. a \<in> \<U> \<Longrightarrow> b \<in> Ua a \<Longrightarrow> openin X b" "\<And>a. a \<in> \<U> \<Longrightarrow> a = \<Inter> (Ua a)"
    using g_delta_ofD[OF assms(1)] by metis
  have 1: "\<Union> {Ua a |a. a \<in> \<U>} \<noteq> {}"
    using assms(3) u(1) by auto
  have 2: "countable (\<Union> {Ua a |a. a \<in> \<U>})"
    by (simp add: Setcompr_eq_image assms(2) u(2))
  have 3: "\<And>b. b \<in> \<Union> {Ua a |a. a \<in> \<U>} \<Longrightarrow> openin X b"
    using u(3) by auto
  show ?thesis
    using u(4) by(fastforce intro!: g_delta_ofI[OF 1 2 3])
qed

lemma g_delta_of_continuous_map:
  assumes "continuous_map X Y f" "g_delta_of Y a"
  shows "g_delta_of X (f -` a \<inter> topspace X)"
proof -
  obtain Ua where u:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin Y b" "a = \<Inter> Ua"
    using g_delta_ofD[OF assms(2)] by metis
  then have 0:"f -` a \<inter> topspace X = \<Inter> {f -` b \<inter> topspace X|b. b \<in> Ua}"
    by auto
  have 1: "{f -` b \<inter> topspace X |b. b \<in> Ua} \<noteq> {}"
    using u(1) by simp
  have 2:"countable {f -` b \<inter> topspace X|b. b \<in> Ua}"
    using u by (simp add: Setcompr_eq_image)
  have 3:"\<And>c. c \<in> {f -` b \<inter> topspace X|b. b \<in> Ua} \<Longrightarrow> openin X c"
    using assms u(3) by blast
  show ?thesis
    using g_delta_ofI[OF 1 2 3] by(simp add: 0)
qed

lemma g_delta_of_inj_open_map:
  assumes "open_map X Y f" "inj_on f (topspace X)" "g_delta_of X a"
  shows "g_delta_of Y (f ` a)"
proof -
  obtain Ua where u:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin X b" "a = \<Inter> Ua"
    using g_delta_ofD[OF assms(3)] by metis
  then obtain j where "j \<in> Ua" by auto
  have "f ` a = f ` \<Inter> Ua" by(simp add: u(4))
  also have "... = \<Inter> ((`) f ` Ua)"
    using u openin_subset by(auto intro!: image_INT[OF assms(2) _ \<open>j \<in> Ua\<close>,of id,simplified])
  also have "... = \<Inter> {f ` u|u. u \<in> Ua}" by auto
  finally have 0: "f ` a = \<Inter> {f ` u |u. u \<in> Ua}" .
  have 1:"{f ` u |u. u \<in> Ua} \<noteq> {}"
    using u(1) by auto
  have 2:"countable {f ` u |u. u \<in> Ua}"
    using u(2) by (simp add: Setcompr_eq_image)
  have 3: "\<And>c. c \<in> {f ` u |u. u \<in> Ua} \<Longrightarrow> openin Y c"
    using assms(1) u(3) by(auto simp: open_map_def)
  show ?thesis
    using g_delta_ofI[OF 1 2 3] by(simp add: 0)
qed

lemma g_delta_of_homeo_morphic:
  assumes "g_delta_of X a" "homeomorphic_map X Y f"
  shows "g_delta_of Y (f ` a)"
  by(auto intro!: g_delta_of_inj_open_map[of X Y f] simp: assms(1) homeomorphic_imp_injective_map[OF assms(2)] homeomorphic_imp_open_map[OF assms(2)])

lemma g_delta_of_prod:
  assumes "g_delta_of X A" "g_delta_of Y B"
  shows "g_delta_of (prod_topology X Y) (A \<times> B)"
proof -
  obtain Ua Ub where hu:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin X b" "A = \<Inter> Ua"
  "Ub \<noteq> {}" "countable Ub" "\<And>b. b \<in> Ub \<Longrightarrow> openin Y b" "B = \<Inter> Ub"
    using assms by(auto simp: g_delta_of_def)
  then have 0:"A \<times> B = \<Inter> {a \<times> b | a b. a \<in> Ua \<and> b \<in> Ub}" by blast
  have 1: "{a \<times> b | a b. a \<in> Ua \<and> b \<in> Ub} \<noteq> {}"
    using hu(1,5) by auto
  have 2: "countable {a \<times> b | a b. a \<in> Ua \<and> b \<in> Ub}"
  proof -
    have "countable ((\<lambda>(x, y). x \<times> y) ` (Ua \<times> Ub))"
      using hu(2,6) by(auto intro!: countable_image[of "Ua \<times> Ub" "\<lambda>(x,y). x \<times> y"])
    moreover have "... = {a \<times> b | a b. a \<in> Ua \<and> b \<in> Ub}" by auto
    ultimately show ?thesis by simp
  qed
  have 3: "\<And>c. c \<in> {a \<times> b | a b. a \<in> Ua \<and> b \<in> Ub} \<Longrightarrow> openin (prod_topology X Y) c"
    using hu(3,7) by(auto simp: openin_prod_Times_iff)
  show ?thesis
    using g_delta_ofI[OF 1 2 3] by(simp add: 0)
qed

lemma g_delta_of_prod1:
  assumes "g_delta_of X A"
  shows "g_delta_of (prod_topology X Y) (A \<times> topspace Y)"
  by(auto intro!: g_delta_of_prod assms)

lemma g_delta_of_prod2:
  assumes "g_delta_of Y B"
  shows "g_delta_of (prod_topology X Y) (topspace X \<times> B)"
  by(auto intro!: g_delta_of_prod assms)

lemma g_delta_of_subtopology:
  assumes "g_delta_of X A" "A \<subseteq> S"
  shows "g_delta_of (subtopology X S) A"
proof -
  obtain Ua where u:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin X b" "A = \<Inter> Ua"
    using g_delta_ofD[OF assms(1)] by metis
  have 0: "\<Inter> Ua = \<Inter> {ua \<inter> S | ua. ua \<in> Ua } "
    using assms(2) u(4) by auto
  have 1: "{ua \<inter> S | ua. ua \<in> Ua } \<noteq> {}"
    using u(1) by auto
  have 2: "countable {ua \<inter> S | ua. ua \<in> Ua }"
    using u(2) by (simp add: Setcompr_eq_image)
  have 3: "\<And>b. b \<in> {ua \<inter> S | ua. ua \<in> Ua } \<Longrightarrow> openin (subtopology X S) b"
    using u(3) by(auto simp: openin_subtopology)
  show ?thesis
    using g_delta_ofI[OF 1 2 3 0] by(simp add: u(4))
qed

lemma g_delta_of_subtopology_inverse:
  assumes "g_delta_of (subtopology X S) A" "g_delta_of X S"
  shows "g_delta_of X A"
proof -
  obtain Ua where ua:
  "Ua \<noteq> {}" "countable Ua" "\<And>b. b \<in> Ua \<Longrightarrow> openin (subtopology X S) b" "A = \<Inter> Ua"
    using g_delta_ofD[OF assms(1)] by metis
  then obtain T where t: "\<And>b. b \<in> Ua \<Longrightarrow> openin X (T b)" "\<And>b. b \<in> Ua \<Longrightarrow> b = T b \<inter> S"
    by(auto simp: openin_subtopology) metis
  have 0: "A = \<Inter> {T b|b. b \<in> Ua} \<inter> S"
    using ua(1,4) t(2) by blast
  have "{T b |b. b \<in> Ua} \<noteq> {}" "countable {T b |b. b \<in> Ua}"
    using ua(1,2) by(simp_all add: Setcompr_eq_image)
  from g_delta_ofI[OF this] t(1) show ?thesis
    by(auto intro!: g_delta_of_inter[OF _ assms(2)] simp: 0)
qed

lemma continuous_map_imp_closed_graph':
  assumes "continuous_map X Y f" "Hausdorff_space Y"
  shows "closedin (prod_topology Y X) ((\<lambda>x. (f x,x)) ` topspace X)"
  using assms closed_map_def closed_map_paired_continuous_map_left by blast

subsubsection \<open> Upper-Semicontinuous \<close>
definition upper_semicontinuous_map :: "['a topology, 'a \<Rightarrow> 'b :: linorder_topology] \<Rightarrow> bool" where
"upper_semicontinuous_map X f \<longleftrightarrow> (\<forall>a. openin X {x\<in>topspace X. f x < a})"

lemma continuous_upper_semicontinuous:
  assumes "continuous_map X (euclidean :: ('b :: linorder_topology) topology) f"
  shows "upper_semicontinuous_map X f"
  unfolding upper_semicontinuous_map_def
proof safe
  fix a :: 'b
  have *:"openin euclidean U \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U}" for U
    using assms by(simp add: continuous_map)
  have "openin euclidean {..<a}" by auto
  with *[of "{..<a}"] show "openin X {x \<in> topspace X. f x < a}" by auto
qed

lemma upper_semicontinuous_map_iff_closed:
 "upper_semicontinuous_map X f \<longleftrightarrow> (\<forall>a. closedin X {x\<in>topspace X. f x \<ge> a})"
proof -
  have "{x \<in> topspace X. f x < a} = topspace X - {x \<in> topspace X. f x \<ge> a}" for a
    by auto
  thus ?thesis
    by (simp add: closedin_def upper_semicontinuous_map_def)
qed

lemma upper_semicontinuous_map_real_iff:
  fixes f :: "'a \<Rightarrow> real"
  shows "upper_semicontinuous_map X f \<longleftrightarrow> upper_semicontinuous_map X (\<lambda>x. ereal (f x))"
  unfolding upper_semicontinuous_map_def
proof safe
  fix a :: ereal
  assume h:"\<forall>a::real. openin X {x \<in> topspace X. f x < a}"
  consider "a = - \<infinity>" | "a = \<infinity>" | "a \<noteq> - \<infinity> \<and> a \<noteq> \<infinity>" by auto
  then show "openin X {x \<in> topspace X. ereal (f x) < a}"
  proof cases
    case 3
    then have "ereal (f x) < a \<longleftrightarrow> f x < real_of_ereal a" for x
      by (metis ereal_less_eq(3) linorder_not_less real_of_ereal.elims)
    thus ?thesis
      using h by simp
  qed simp_all
next
  fix a :: real
  assume h:"\<forall>a::ereal. openin X {x \<in> topspace X. ereal (f x) < a}"
  then have "openin X {x \<in> topspace X. ereal (f x) < ereal a}"
    by blast
  moreover have"ereal (f x) < real_of_ereal a \<longleftrightarrow> f x < a" for x
    by auto
  ultimately show "openin X {x \<in> topspace X. f x < a}" by auto
qed

subsection \<open> Lemmas for Limits\<close>
lemma qlim_eq_lim_mono_at_bot:
  fixes g :: "rat \<Rightarrow> 'a :: linorder_topology"
  assumes "mono f" "(g \<longlongrightarrow> a) at_bot" "\<And>r::rat. f (real_of_rat r) = g r"
  shows "(f \<longlongrightarrow> a) at_bot"
proof -
  have "mono g"
    by(metis assms(1,3) mono_def of_rat_less_eq)
  have ga:"\<And>r. g r \<ge> a"
  proof(rule ccontr)
    fix r
    assume "\<not> a \<le> g r"
    then have "g r < a" by simp
    from order_topology_class.order_tendstoD(1)[OF assms(2) this]
    obtain Q :: rat where q: "\<And>q. q \<le> Q \<Longrightarrow> g r < g q"
      by(auto simp: eventually_at_bot_linorder)
    define q where "q \<equiv> min r Q"
    show False
      using q[of q] \<open>mono g\<close>
      by(auto simp: q_def mono_def) (meson linorder_not_less min.cobounded1)
  qed
  show ?thesis
  proof(rule decreasing_tendsto)
    show "\<forall>\<^sub>F n in at_bot. a \<le> f n"
      unfolding eventually_at_bot_linorder
      by(rule exI[where x=undefined],auto) (metis Ratreal_def assms(1,3) dual_order.trans ga less_eq_real_def lt_ex monoD of_rat_dense) (*metis assms(1) assms(3) ga less_eq_real_def lfp.leq_trans lt_ex monoD of_rat_dense*)
  next
    fix x
    assume "a < x"
    with topological_space_class.topological_tendstoD[OF assms(2),of "{..<x}"]
    obtain Q :: rat where q: "\<And>q. q \<le> Q \<Longrightarrow> g q < x"
      by(auto simp: eventually_at_bot_linorder)
    show "\<forall>\<^sub>F n in at_bot. f n < x"
      using q assms(1,3) by(auto intro!: exI[where x="real_of_rat Q"] simp: eventually_at_bot_linorder) (metis dual_order.refl monoD order_le_less_trans)
  qed
qed

lemma qlim_eq_lim_mono_at_top:
  fixes g :: "rat \<Rightarrow> 'a :: linorder_topology"
  assumes "mono f" "(g \<longlongrightarrow> a) at_top" "\<And>r::rat. f (real_of_rat r) = g r"
  shows "(f \<longlongrightarrow> a) at_top"
proof -
  have "mono g"
    by(metis assms(1,3) mono_def of_rat_less_eq)
  have ga:"\<And>r. g r \<le> a"
  proof(rule ccontr)
    fix r
    assume "\<not> g r \<le> a"
    then have "a < g r" by simp
    from order_topology_class.order_tendstoD(2)[OF assms(2) this]
    obtain Q :: rat where q: "\<And>q. Q \<le> q \<Longrightarrow> g q < g r"
      by(auto simp: eventually_at_top_linorder)
    define q where "q \<equiv> max r Q"
    show False
      using q[of q] \<open>mono g\<close> by(auto simp: q_def mono_def leD)
  qed
  show ?thesis
  proof(rule increasing_tendsto)
    show "\<forall>\<^sub>F n in at_top. f n \<le> a"
      unfolding eventually_at_top_linorder
      by(rule exI[where x=undefined],auto) (metis (no_types, opaque_lifting) assms(1) assms(3) dual_order.trans ga gt_ex monoD of_rat_dense order_le_less)
  next
    fix x
    assume "x < a"
    with topological_space_class.topological_tendstoD[OF assms(2),of "{x<..}"]
    obtain Q :: rat where q: "\<And>q. Q \<le> q \<Longrightarrow> x < g q"
      by(auto simp: eventually_at_top_linorder)
    show "\<forall>\<^sub>F n in at_top. x < f n"
      using q assms(1,3) by(auto simp: eventually_at_top_linorder intro!: exI[where x="real_of_rat Q"]) (metis dual_order.refl monoD order_less_le_trans)
  qed
qed

lemma tendsto_enn2real:
  assumes "k < top" and "(f \<longlongrightarrow> k) F"
  shows "((\<lambda>n. enn2real  (f n)) \<longlongrightarrow>  enn2real k) F"
proof -
  have 1:"ennreal (enn2real k) = k" "enn2real k \<ge> 0"
    using assms(1) by auto
  show ?thesis
    using assms tendsto_enn2real[OF _ 1(2),of f]
    by(simp add: 1(1))
qed

lemma LIMSEQ_inverse_not0:
  fixes xn :: "nat \<Rightarrow> real"
  assumes "\<And>n. xn n \<noteq> 0" "xn \<longlonglongrightarrow> x" "(\<lambda>n. 1 / (xn n)) \<longlonglongrightarrow> b"
  shows "x \<noteq> 0"
proof
  assume x:"x = 0"
  then have xn:"\<And>e. e > 0 \<Longrightarrow> \<exists>N. \<forall>n\<ge>N. \<bar>xn n\<bar> < e"
    using LIMSEQ_D[OF assms(2)] by simp
  have "\<exists>N. \<forall>n\<ge>N. \<bar>1 / (xn n) - b\<bar> \<ge> r" if r:"r > 0" for r
  proof -
    have "0 < 1 / (r + \<bar>b\<bar>)"
      using that by auto
    with xn[OF this] obtain N where N':"\<And>n. n \<ge> N \<Longrightarrow> \<bar>xn n\<bar> < 1 / (r + \<bar>b\<bar>)"
      by auto
    show ?thesis
    proof(rule exI[where x=N])
      show "\<forall>n\<ge>N. r \<le> \<bar>1 / xn n - b\<bar>"
      proof safe
        fix n
        assume "n \<ge> N"
        note N'[OF this]
        hence "(r + \<bar>b\<bar>) * \<bar>xn n\<bar> < 1"
          by (metis \<open>0 < 1 / (r + \<bar>b\<bar>)\<close> mult.commute pos_less_divide_eq zero_less_divide_1_iff) 
        hence "1 / \<bar>xn n\<bar> > r + \<bar>b\<bar>"
          using assms(1)[of n] by (simp add: less_divide_eq)
        hence "r + \<bar>b\<bar> - \<bar>b\<bar> < 1 / \<bar>xn n\<bar> - \<bar>b\<bar>"
          by simp
        also have "... = \<bar>1 / xn n\<bar> - \<bar>b\<bar>" by simp
        also have "... \<le> \<bar>1 / xn n - b\<bar>" by simp
        finally show  "r \<le> \<bar>1 / xn n - b\<bar>"
          by simp
      qed
    qed
  qed
  with LIMSEQ_D[OF assms(3)] show False
    by (metis less_le_not_le linorder_le_cases real_norm_def zero_less_one)
qed

lemma obtain_subsequence:
  fixes xn :: "nat \<Rightarrow> _"
  assumes "infinite {n. P n (xn n)}"
  obtains a :: "nat \<Rightarrow> nat" where "strict_mono a" "\<And>n. P (a n) (xn (a n))"
proof -
  have inf: "infinite {n. n > m \<and> P n (xn n)}" for m
  proof
    assume "finite {n. n > m \<and> P n (xn n)}"
    then have "finite ({..m} \<union> {n. n > m \<and> P n (xn n)})" by auto
    hence "finite {n. P n (xn n)}"
      by(auto intro!: finite_subset[where B="{..m} \<union> {n. n > m \<and> P n (xn n)}"])
    with assms show False by simp
  qed
  define an where "an \<equiv> rec_nat (SOME n. P n (xn n)) (\<lambda>n an. SOME m. m > an \<and> P m (xn m))"
  have anSome: "an (Suc n) = (SOME m. m > an n \<and> P m (xn m))" for n
    by(auto simp: an_def)
  have an1: "P (an n) (xn (an n))" for n
  proof(cases n)
    case 0
    obtain m where m:"P m (xn m)"
      using assms not_finite_existsD by blast
    show ?thesis 
      by(simp add: an_def 0,rule someI,rule m)
  next
    case (Suc n')
    obtain m where m:"m > an n'" "P m (xn m)"
      using inf not_finite_existsD by blast
    show ?thesis
      by(simp add: Suc anSome, rule someI2[where a=m],auto simp: m)
  qed
  have an2: "strict_mono an"
    unfolding strict_mono_Suc_iff anSome
  proof safe
    fix n
    obtain m where m:"m > an n" "P m (xn m)"
      using inf not_finite_existsD by blast
    show "an n < (SOME m. an n < m \<and> P m (xn m))"
      by (rule someI2[where a=m],auto simp: m)
  qed
  show ?thesis
    using an1 that[OF an2] by auto
qed

subsection \<open>Lemmas for Measure Theory\<close>
lemma measurable_preserve_sigma_sets:
  assumes "sets M = sigma_sets \<Omega> S" "S \<subseteq> Pow \<Omega>"
          "\<And>a. a \<in> S \<Longrightarrow> f ` a \<in> sets N" "inj_on f (space M)" "f ` space M \<in> sets N"
      and "b \<in> sets M" 
    shows "f ` b \<in> sets N"
proof -
  have "b \<in> sigma_sets \<Omega> S"
    using assms(1,6) by simp
  thus ?thesis
  proof induction
    case (Basic a)
    then show ?case by(rule assms(3))
  next
    case Empty
    then show ?case by simp
  next
    case (Compl a)
    moreover have " \<Omega> = space M"
      by (metis assms(1) assms(2) sets.sets_into_space sets.top sigma_sets_into_sp sigma_sets_top subset_antisym)
    ultimately show ?case
      by (metis Diff_subset assms(2) assms(4) assms(5) inj_on_image_set_diff sets.Diff sigma_sets_into_sp)
  next
    case (Union a)
    then show ?case
      by (simp add: image_UN)
  qed
qed

lemma integral_measurable_subprob_algebra2:
  fixes f :: "_ \<Rightarrow> _ \<Rightarrow> _::{banach,second_countable_topology}"
  assumes [measurable]: "(\<lambda>(x, y). f x y) \<in> borel_measurable (M \<Otimes>\<^sub>M N)" "L \<in> measurable M (subprob_algebra N)"
  shows "(\<lambda>x. integral\<^sup>L (L x) (f x)) \<in> borel_measurable M"
proof -
  note integral_measurable_subprob_algebra[measurable]
  note measurable_distr2[measurable]
  have "(\<lambda>x. integral\<^sup>L (distr (L x) (M \<Otimes>\<^sub>M N) (\<lambda>y. (x, y))) (\<lambda>(x, y). f x y)) \<in> borel_measurable M"
    by measurable
  then show "(\<lambda>x. integral\<^sup>L (L x) (f x)) \<in> borel_measurable M"
    by (rule measurable_cong[THEN iffD1, rotated])
       (simp add: integral_distr)
qed

inductive_set sigma_sets_cinter :: "'a set \<Rightarrow> 'a set set \<Rightarrow> 'a set set"
  for sp :: "'a set" and A :: "'a set set"
  where
    Basic_c[intro, simp]: "a \<in> A \<Longrightarrow> a \<in> sigma_sets_cinter sp A"
  | Top_c[simp]: "sp \<in> sigma_sets_cinter sp A"
  | Inter_c: "(\<And>i::nat. a i \<in> sigma_sets_cinter sp A) \<Longrightarrow> (\<Inter>i. a i) \<in> sigma_sets_cinter sp A"
  | Union_c: "(\<And>i::nat. a i \<in> sigma_sets_cinter sp A) \<Longrightarrow> (\<Union>i. a i) \<in> sigma_sets_cinter sp A"

inductive_set sigma_sets_cinter_dunion :: "'a set \<Rightarrow> 'a set set \<Rightarrow> 'a set set"
  for sp :: "'a set" and A :: "'a set set"
  where
    Basic_cd[intro, simp]: "a \<in> A \<Longrightarrow> a \<in> sigma_sets_cinter_dunion sp A"
  | Top_cd[simp]: "sp \<in> sigma_sets_cinter_dunion sp A"
  | Inter_cd: "(\<And>i::nat. a i \<in> sigma_sets_cinter_dunion sp A) \<Longrightarrow> (\<Inter>i. a i) \<in> sigma_sets_cinter_dunion sp A"
  | Union_cd: "(\<And>i::nat. a i \<in> sigma_sets_cinter_dunion sp A) \<Longrightarrow> disjoint_family a \<Longrightarrow> (\<Union>i. a i) \<in> sigma_sets_cinter_dunion sp A"

lemma sigma_sets_cinter_dunion_subset: "sigma_sets_cinter_dunion sp A \<subseteq> sigma_sets_cinter sp A"
proof safe
  fix x
  assume "x \<in> sigma_sets_cinter_dunion sp A"
  then show "x \<in> sigma_sets_cinter sp A"
    by induction (auto intro!: Union_c Inter_c)
qed

lemma sigma_sets_cinter_into_sp:
  assumes "A \<subseteq> Pow sp" "x \<in> sigma_sets_cinter sp A"
  shows "x \<subseteq> sp"
  using assms(2) by induction (use assms(1) subsetD in blast)+

lemma sigma_sets_cinter_dunion_into_sp:
  assumes "A \<subseteq> Pow sp" "x \<in> sigma_sets_cinter_dunion sp A"
  shows "x \<subseteq> sp"
  using assms(2) by induction (use assms(1) subsetD in blast)+

lemma sigma_sets_cinter_int:
  assumes "a \<in> sigma_sets_cinter sp A" "b \<in> sigma_sets_cinter sp A"
  shows "a \<inter> b \<in> sigma_sets_cinter sp A"
proof -
  have 1:"a \<inter> b = (\<Inter>i::nat. if i = 0 then a else b)" by auto
  show ?thesis
    unfolding 1 by(rule Inter_c,use assms in auto)
qed

lemma sigma_sets_cinter_dunion_int:
  assumes "a \<in> sigma_sets_cinter_dunion sp A" "b \<in> sigma_sets_cinter_dunion sp A"
  shows "a \<inter> b \<in> sigma_sets_cinter_dunion sp A"
proof -
  have 1:"a \<inter> b = (\<Inter>i::nat. if i = 0 then a else b)" by auto
  show ?thesis
    unfolding 1 by(rule Inter_cd,use assms in auto)
qed

lemma sigma_sets_cinter_un:
  assumes "a \<in> sigma_sets_cinter sp A" "b \<in> sigma_sets_cinter sp A"
  shows "a \<union> b \<in> sigma_sets_cinter sp A"
proof -
  have 1:"a \<union> b = (\<Union>i::nat. if i = 0 then a else b)" by auto
  show ?thesis
    unfolding 1 by(rule Union_c,use assms in auto)
qed

text \<open> Measurable isomorphisms.\<close>
definition measurable_isomorphic_map::"['a measure, 'b measure, 'a \<Rightarrow> 'b] \<Rightarrow> bool" where
"measurable_isomorphic_map M N f \<longleftrightarrow> bij_betw f (space M) (space N) \<and> f \<in> M \<rightarrow>\<^sub>M N \<and> the_inv_into (space M) f \<in> N \<rightarrow>\<^sub>M M"

lemma measurable_isomorphic_map_sets_cong:
  assumes "sets M = sets M'" "sets N = sets N'"
  shows "measurable_isomorphic_map M N f \<longleftrightarrow> measurable_isomorphic_map M' N' f"
  by(simp add: measurable_isomorphic_map_def sets_eq_imp_space_eq[OF assms(1)] sets_eq_imp_space_eq[OF assms(2)] measurable_cong_sets[OF assms] measurable_cong_sets[OF assms(2,1)])

lemma measurable_isomorphic_map_surj:
  assumes "measurable_isomorphic_map M N f"
  shows "f ` space M = space N"
  using assms by(auto simp: measurable_isomorphic_map_def bij_betw_def)

lemma measurable_isomorphic_mapI:
  assumes "bij_betw f (space M) (space N)" "f \<in> M \<rightarrow>\<^sub>M N" "the_inv_into (space M) f \<in> N \<rightarrow>\<^sub>M M"
  shows "measurable_isomorphic_map M N f"
  using assms by(simp add: measurable_isomorphic_map_def)

lemma measurable_isomorphic_map_byWitness:
  assumes "f \<in> M \<rightarrow>\<^sub>M N" "g \<in> N \<rightarrow>\<^sub>M M" "\<And>x. x \<in> space M \<Longrightarrow> g (f x) = x" "\<And>x. x \<in> space N \<Longrightarrow> f (g x) = x"
  shows "measurable_isomorphic_map M N f"
proof -
  have *:"bij_betw f (space M) (space N)"
    using assms by(auto intro!: bij_betw_byWitness[where f'=g] dest:measurable_space)
  show ?thesis
  proof(rule measurable_isomorphic_mapI)
    have "the_inv_into (space M) f x = g x" if "x \<in> space N" for x
      by (metis * assms(2) assms(4) bij_betw_imp_inj_on measurable_space that the_inv_into_f_f)
    thus "the_inv_into (space M) f \<in> N \<rightarrow>\<^sub>M M"
      using measurable_cong assms(2) by blast
  qed (simp_all add: * assms(1))
qed

lemma measurable_isomorphic_map_restrict_space:
  assumes "f \<in> M \<rightarrow>\<^sub>M N" "\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets N" "inj_on f (space M)"
  shows "measurable_isomorphic_map M (restrict_space N (f ` space M)) f"
proof(rule measurable_isomorphic_mapI)
  show "bij_betw f (space M) (space (restrict_space N (f ` space M)))"
    by (simp add: assms(2,3) inj_on_imp_bij_betw)
next
  show "f \<in> M \<rightarrow>\<^sub>M restrict_space N (f ` space M)"
    by (simp add: assms(1) measurable_restrict_space2)
next
  show "the_inv_into (space M) f \<in> restrict_space N (f ` space M) \<rightarrow>\<^sub>M M"
  proof(rule measurableI)
    show "x \<in> space (restrict_space N (f ` space M)) \<Longrightarrow> the_inv_into (space M) f x \<in> space M" for x
      by (simp add: assms(2,3) the_inv_into_into)
  next
    fix A
    assume "A \<in> sets M"
    have "the_inv_into (space M) f -` A \<inter> space (restrict_space N (f ` space M)) = f ` A"
      by (simp add: \<open>A \<in> sets M\<close> assms(2,3) sets.sets_into_space the_inv_into_vimage)
    also note assms(2)[OF \<open>A \<in> sets M\<close>]
    finally show "the_inv_into (space M) f -` A \<inter> space (restrict_space N (f ` space M)) \<in> sets (restrict_space N (f ` space M))"
      by (simp add: assms(2) sets_restrict_space_iff)
  qed
qed

lemma measurable_isomorphic_mapD':
  assumes "measurable_isomorphic_map M N f"
  shows "\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets N" "f \<in> M \<rightarrow>\<^sub>M N"
        "\<exists>g. bij_betw g (space N) (space M) \<and> g \<in> N \<rightarrow>\<^sub>M M \<and> (\<forall>x \<in> space M. g (f x) = x) \<and> (\<forall>x\<in> space N. f (g x) = x) \<and> (\<forall>A\<in>sets N. g ` A \<in> sets M)"
proof -
  have h:"bij_betw f (space M) (space N)" "f \<in> M \<rightarrow>\<^sub>M N" "the_inv_into (space M) f \<in> N \<rightarrow>\<^sub>M M"
    using assms by(simp_all add: measurable_isomorphic_map_def)
  show "f ` A \<in> sets N" if "A \<in> sets M" for A
  proof -
    have "f ` A = the_inv_into (space M) f -` A \<inter> space N"
      using the_inv_into_vimage[OF bij_betw_imp_inj_on[OF h(1)] sets.sets_into_space[OF that]]
      by(simp add: bij_betw_imp_surj_on[OF h(1)])
    also have "... \<in> sets N"
      using that h(3) by auto
    finally show ?thesis .
  qed
  show "f \<in> M \<rightarrow>\<^sub>M N"
    using assms by(simp add: measurable_isomorphic_map_def)

  show "\<exists>g. bij_betw g (space N) (space M) \<and> g \<in> N \<rightarrow>\<^sub>M M \<and> (\<forall>x \<in> space M. g (f x) = x) \<and> (\<forall>x\<in> space N. f (g x) = x) \<and> (\<forall>A\<in>sets N. g ` A \<in> sets M)"
  proof(rule exI[where x="the_inv_into (space M) f"])
    have *:"the_inv_into (space M) f ` A \<in> sets M" if "A \<in> sets N" for A
    proof -
      have "\<And>x. x \<in> space M \<Longrightarrow> the_inv_into (space N) (the_inv_into (space M) f) x = f x"
        by (metis bij_betw_imp_inj_on bij_betw_the_inv_into h(1) h(2) measurable_space the_inv_into_f_f)
      from vimage_inter_cong[of "space M" _ f A,OF this] the_inv_into_vimage[OF bij_betw_imp_inj_on[OF bij_betw_the_inv_into[OF h(1)]] sets.sets_into_space[OF that]]
           bij_betw_imp_surj_on[OF bij_betw_the_inv_into[OF h(1)]] measurable_sets[OF h(2) that]
      show ?thesis
        by fastforce
    qed
    show "bij_betw (the_inv_into (space M) f) (space N) (space M) \<and> the_inv_into (space M) f \<in> N \<rightarrow>\<^sub>M M \<and> (\<forall>x\<in>space M. the_inv_into (space M) f (f x) = x) \<and> (\<forall>x\<in>space N. f (the_inv_into (space M) f x) = x) \<and> (\<forall>A\<in>sets N. the_inv_into (space M) f ` A \<in> sets M)"
      using bij_betw_the_inv_into[OF h(1)]
      by (meson * bij_betw_imp_inj_on f_the_inv_into_f_bij_betw h(1) h(3) the_inv_into_f_f)
  qed
qed

lemma measurable_isomorphic_map_inv:
  assumes "measurable_isomorphic_map M N f"
  shows "measurable_isomorphic_map N M (the_inv_into (space M) f)"
  using assms[simplified measurable_isomorphic_map_def]
  by(auto intro!: measurable_isomorphic_map_byWitness[where g=f] bij_betw_the_inv_into f_the_inv_into_f_bij_betw[of f] bij_betw_imp_inj_on the_inv_into_f_f)

lemma measurable_isomorphic_map_comp:
  assumes "measurable_isomorphic_map M N f" and "measurable_isomorphic_map N L g"
  shows "measurable_isomorphic_map M L (g \<circ> f)"
proof -
  obtain f' g' where
  [measurable]: "f' \<in> N \<rightarrow>\<^sub>M M"     and hf:"\<And>x. x\<in>space M \<Longrightarrow> f' (f x) = x" "\<And>x. x\<in>space N \<Longrightarrow> f (f' x) = x"
  and [measurable]: "g' \<in> L \<rightarrow>\<^sub>M N" and hg:"\<And>x. x\<in>space N \<Longrightarrow> g' (g x) = x" "\<And>x. x\<in>space L \<Longrightarrow> g (g' x) = x"
    using measurable_isomorphic_mapD'[OF assms(1)] measurable_isomorphic_mapD'[OF assms(2)] by metis
  have [measurable]: "f \<in> M \<rightarrow>\<^sub>M N" "g \<in> N \<rightarrow>\<^sub>M L"
    using assms by(auto simp: measurable_isomorphic_map_def)
  from hf hg measurable_space[OF \<open>f \<in> M \<rightarrow>\<^sub>M N\<close>] measurable_space[OF \<open>g' \<in> L \<rightarrow>\<^sub>M N\<close>] show ?thesis
    by(auto intro!: measurable_isomorphic_map_byWitness[where g="f'\<circ>g'"])
qed

definition measurable_isomorphic::"['a measure, 'b measure] \<Rightarrow> bool" (infixr "measurable'_isomorphic" 50) where
"M measurable_isomorphic N \<longleftrightarrow> (\<exists>f. measurable_isomorphic_map M N f)"

lemma measurable_isomorphic_sets_cong:
  assumes "sets M = sets M'" "sets N = sets N'"
  shows "M measurable_isomorphic N  \<longleftrightarrow> M' measurable_isomorphic N'"
  using measurable_isomorphic_map_sets_cong[OF assms]
  by(auto simp: measurable_isomorphic_def)


lemma measurable_isomorphicD:
  assumes "M measurable_isomorphic N"
  shows "\<exists>f g. f \<in> M \<rightarrow>\<^sub>M N \<and> g \<in> N \<rightarrow>\<^sub>M M \<and> (\<forall>x\<in>space M. g (f x) = x) \<and> (\<forall>y\<in>space N. f (g y) = y) \<and> (\<forall>A\<in>sets M. f ` A \<in> sets N) \<and> (\<forall>A\<in>sets N. g ` A \<in> sets M)"
  using assms measurable_isomorphic_mapD'[of M N]
  by (metis (mono_tags, lifting) measurable_isomorphic_def)

lemma measurable_isomorphic_byWitness:
  assumes "f \<in> M \<rightarrow>\<^sub>M N" "\<And>x. x\<in>space M \<Longrightarrow> g (f x) = x"
      and "g \<in> N \<rightarrow>\<^sub>M M" "\<And>y. y\<in>space N \<Longrightarrow> f (g y) = y"
    shows "M measurable_isomorphic N"
  by(auto simp: measurable_isomorphic_def assms intro!: exI[where x = f] measurable_isomorphic_map_byWitness[where g=g])

lemma measurable_isomorphic_refl:
  "M measurable_isomorphic M"
  by(auto intro!: measurable_isomorphic_byWitness[where f=id and g=id])

lemma measurable_isomorphic_sym:
  assumes "M measurable_isomorphic N"
  shows "N measurable_isomorphic M"
  using assms measurable_isomorphic_map_inv[of M N]
  by(auto simp: measurable_isomorphic_def)

lemma measurable_isomorphic_trans:
  assumes "M measurable_isomorphic N" and "N measurable_isomorphic L"
  shows "M measurable_isomorphic L"
  using assms measurable_isomorphic_map_comp[of M N _ L]
  by(auto simp: measurable_isomorphic_def)

lemma measurable_isomorphic_empty:
  assumes "space M = {}" "space N = {}"
  shows "M measurable_isomorphic N"
  using assms by(auto intro!: measurable_isomorphic_byWitness[where f=undefined and g=undefined] simp: measurable_empty_iff)

lemma measurable_isomorphic_empty1:
  assumes "space M = {}" "M measurable_isomorphic N"
  shows "space N = {}"
  using measurable_isomorphicD[OF assms(2)] by(auto simp: measurable_empty_iff[OF assms(1)])

lemma measurable_ismorphic_empty2:
  assumes "space N = {}" "M measurable_isomorphic N"
  shows "space M = {}"
  using measurable_isomorphic_sym[OF assms(2)] assms(1)
  by(simp add: measurable_isomorphic_empty1)

lemma measurable_lift_product:
  assumes "\<And>i. i \<in> I \<Longrightarrow> f i \<in> (M i) \<rightarrow>\<^sub>M (N i)"
  shows "(\<lambda>x i. if i \<in> I then f i (x i) else undefined) \<in> (\<Pi>\<^sub>M i\<in>I. M i) \<rightarrow>\<^sub>M (\<Pi>\<^sub>M i\<in>I. N i)"
  using measurable_space[OF assms]
  by(auto intro!: measurable_PiM_single' simp: assms measurable_PiM_component_rev space_PiM PiE_iff)

lemma measurable_isomorphic_map_lift_product:
  assumes "\<And>i. i \<in> I \<Longrightarrow> measurable_isomorphic_map (M i) (N i) (h i)"
  shows "measurable_isomorphic_map (\<Pi>\<^sub>M i\<in>I. M i) (\<Pi>\<^sub>M i\<in>I. N i) (\<lambda>x i. if i \<in> I then h i (x i) else undefined)"
proof -
  obtain h' where
   "\<And>i. i \<in> I \<Longrightarrow> h' i \<in> (N i) \<rightarrow>\<^sub>M (M i)" "\<And>i x. i \<in> I \<Longrightarrow> x\<in>space (M i) \<Longrightarrow> h' i (h i x) = x" "\<And>i x. i \<in> I \<Longrightarrow> x\<in>space (N i) \<Longrightarrow> h i (h' i x) = x"
    using measurable_isomorphic_mapD'(3)[OF assms] by metis
  thus ?thesis
    by(auto intro!: measurable_isomorphic_map_byWitness[OF measurable_lift_product[of I h M N,OF measurable_isomorphic_mapD'(2)[OF assms]] measurable_lift_product[of I h' N M,OF \<open>\<And>i. i \<in> I \<Longrightarrow> h' i \<in> (N i) \<rightarrow>\<^sub>M (M i)\<close>]]
              simp: space_PiM PiE_iff extensional_def)
qed

lemma measurable_isomorphic_lift_product:
  assumes "\<And>i. i \<in> I \<Longrightarrow> (M i) measurable_isomorphic (N i)"
  shows "(\<Pi>\<^sub>M i\<in>I. M i) measurable_isomorphic  (\<Pi>\<^sub>M i\<in>I. N i)"
proof -
  obtain h where "\<And>i. i \<in> I \<Longrightarrow> measurable_isomorphic_map (M i) (N i) (h i)"
    using assms by(auto simp: measurable_isomorphic_def) metis
  thus ?thesis
    by(auto intro!: measurable_isomorphic_map_lift_product exI[where x="\<lambda>x i. if i \<in> I then h i (x i) else undefined"] simp: measurable_isomorphic_def)
qed

text \<open>\<^url>\<open>https://math24.net/cantor-schroder-bernstein-theorem.html\<close>\<close>
lemma Schroeder_Bernstein_measurable':
  assumes "f ` (space M) \<in> sets N" "g ` (space N) \<in> sets M"
      and "measurable_isomorphic_map M (restrict_space N (f ` (space M))) f" and "measurable_isomorphic_map N (restrict_space M (g ` (space N))) g"
    shows "\<exists>h. measurable_isomorphic_map M N h"
proof -
  have hset:"\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets (restrict_space N (f ` space M))" 
            "\<And>A. A \<in> sets N \<Longrightarrow> g ` A \<in> sets (restrict_space M (g ` space N))" 
  and hfg[measurable]:"f \<in> M \<rightarrow>\<^sub>M restrict_space N (f ` space M)"
                      "g \<in> N \<rightarrow>\<^sub>M restrict_space M (g ` space N)"
    using measurable_isomorphic_mapD'(1,2)[OF assms(3)]  measurable_isomorphic_mapD'(1,2)[OF assms(4)] assms(1,2)
    by auto
  have hset2:"\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets N" "\<And>A. A \<in> sets N \<Longrightarrow> g ` A \<in> sets M"
   and hfg2[measurable]: "f \<in> M \<rightarrow>\<^sub>M N" "g \<in> N \<rightarrow>\<^sub>M M"
    using sets.Int_space_eq2[OF assms(1)] sets.Int_space_eq2[OF assms(2)] sets_restrict_space_iff[of "f ` space M" N] sets_restrict_space_iff[of "g ` space N" M] hset
          measurable_restrict_space2_iff[of f M N] measurable_restrict_space2_iff[of g N M] hfg assms(1,2)
    by auto
  have bij1:"bij_betw f (space M) (f ` (space M))" "bij_betw g (space N) (g ` (space N))"
    using assms(3,4) by(auto simp: measurable_isomorphic_map_def space_restrict_space sets.Int_space_eq2[OF assms(1)] sets.Int_space_eq2[OF assms(2)])
  obtain f' g' where
  hfg1'[measurable]: "f' \<in> restrict_space N (f ` (space M)) \<rightarrow>\<^sub>M M" "g' \<in> restrict_space M (g ` (space N)) \<rightarrow>\<^sub>M N"
    and hfg':"\<And>x. x\<in>space M \<Longrightarrow> f' (f x) = x" "\<And>x. x\<in>f ` space M \<Longrightarrow> f (f' x) = x"
             "\<And>x. x\<in>space N \<Longrightarrow> g' (g x) = x" "\<And>x. x\<in>g ` space N \<Longrightarrow> g (g' x) = x"
             "bij_betw f' (f ` space M) (space M)" "bij_betw g' (g ` space N) (space N)"
    using measurable_isomorphic_mapD'(3)[OF assms(3)] measurable_isomorphic_mapD'(3)[OF assms(4)] sets.Int_space_eq2[OF assms(1)] sets.Int_space_eq2[OF assms(2)]
    by (metis space_restrict_space)

  have hgfA:"(g \<circ> f) ` A \<in> sets M" if "A \<in> sets M" for A
    using hset2(2)[OF hset2(1)[OF that]] by(simp add: image_comp)
  define An where "An \<equiv> (\<lambda>n. ((g \<circ> f)^^n) ` (space M - g ` (space N)))"
  define A where "A \<equiv> (\<Union>n\<in>UNIV. An n)"
  have "An n \<in> sets M" for n
  proof(induction n)
    case 0
    thus ?case
      using hset2[OF sets.top] by(simp add: An_def)
  next
    case ih:(Suc n)
    have "An (Suc n) = (g \<circ> f) ` (An n)"
      by(auto simp add: An_def)
    thus ?case
      using hgfA[OF ih] by simp
  qed
  hence Asets:"A \<in> sets M"
    by(simp add: A_def)
  have Acompl:"space M - A \<subseteq> g ` space N"
  proof -
    have "space M - A \<subseteq> space M - An 0"
      by(auto simp: A_def)
    also have "... \<subseteq> g ` space N"
      by(auto simp: An_def)
    finally show ?thesis .
  qed
  define h where "h \<equiv> (\<lambda>x. if x \<in> A \<union> (- space M) then f x else g' x)"
  define h' where "h' \<equiv> (\<lambda>x. if x \<in> f ` A then f' x else g x)"
  have xinA_iff:"x \<in> A \<longleftrightarrow> h x \<in> f ` A" if "x \<in> space M" for x
  proof
    assume "h x \<in> f ` A"
    show "x \<in> A"
    proof(rule ccontr)
      assume "x \<notin> A"
      then have "\<And>n. x \<notin> An n"
        by(auto simp: A_def)
      from this[of 0] have "x \<in> g ` (space N)"
        using that by(auto simp: An_def)
      have "g' x \<in> f ` A "
        using \<open>h x \<in> f ` A\<close> \<open>x \<notin> A\<close>
        by (simp add: h_def that)
      hence "g (g' x) \<in> (g \<circ> f) ` A"
        by auto
      hence "x \<in> (g \<circ> f) ` A"
        using \<open>x \<in> g ` (space N)\<close> by (simp add: hfg'(4))
      then obtain n where "x \<in> (g \<circ> f) ` (An n)"
        by(auto simp: A_def)
      hence "x \<in> An (Suc n)"
        by(auto simp: An_def)
      thus False
        using \<open>\<And>n. x \<notin> An n\<close> by simp
    qed
  qed(simp add: h_def)

  show ?thesis
  proof(intro exI[where x=h] measurable_isomorphic_map_byWitness[where g=h'])
    have "{x \<in> space M. x \<in> A \<union> (- space M)} \<in> sets M"
      using sets.Int_space_eq2[OF Asets] Asets by simp
    moreover have "f \<in> restrict_space M {x. x \<in> A \<union> - space M} \<rightarrow>\<^sub>M N"
      by (simp add: measurable_restrict_space1)
    moreover have "g' \<in> restrict_space M {x. x \<notin>  A \<union> (- space M)} \<rightarrow>\<^sub>M N"
    proof -
      have "sets (restrict_space (restrict_space M (g ` space N))  {x. x \<notin> A \<union> - space M}) = sets (restrict_space M (g ` space N \<inter>  {x. x \<notin> A \<union> - space M}))"
        by(simp add: sets_restrict_restrict_space)
      also have "... = sets (restrict_space M (g ` space N \<inter> {x. x \<in> space M - A}))"
        by (metis Compl_iff DiffE DiffI Un_iff)
      also have "... = sets (restrict_space M {x. x \<in> space M - A})"
        by (metis Acompl le_inf_iff mem_Collect_eq subsetI subset_antisym)
      also have "... = sets (restrict_space M {x. x \<notin>  A \<union> (- space M)})"
        by (metis Compl_iff DiffE DiffI Un_iff)
      finally have "sets (restrict_space (restrict_space M (g ` space N)) {x. x \<notin> A \<union> - space M}) = sets (restrict_space M {x. x \<notin> A \<union> - space M})" .
      from measurable_cong_sets[OF this refl] measurable_restrict_space1[OF hfg1'(2),of " {x. x \<notin> A \<union> - space M}"]
      show ?thesis by auto
    qed
    ultimately show "h \<in> M \<rightarrow>\<^sub>M N"
      by(simp add: h_def measurable_If_restrict_space_iff)
  next
    have "{x \<in> space N. x \<in> f ` A} \<in> sets N"
      using sets.Int_space_eq2[OF hset2(1)[OF Asets]] hset2(1)[OF Asets] by simp
    moreover have "f' \<in> restrict_space N {x. x \<in> f ` A} \<rightarrow>\<^sub>M M"
    proof -
      have "sets (restrict_space (restrict_space N (f ` space M)) {x. x \<in> f ` A}) = sets (restrict_space N (f ` space M \<inter> {x. x \<in> f ` A}))"
        by(simp add: sets_restrict_restrict_space)
      also have "... = sets (restrict_space N {x. x \<in> f ` A})"
      proof -
        have "f ` space M \<inter> {x. x \<in> f ` A} = {x. x \<in> f ` A}"
          using sets.sets_into_space[OF Asets] by auto
        thus ?thesis by simp
      qed
      finally have "sets (restrict_space (restrict_space N (f ` space M)) {x. x \<in> f ` A}) = sets (restrict_space N {x. x \<in> f ` A})" .
      from measurable_cong_sets[OF this refl] measurable_restrict_space1[OF hfg1'(1),of "{x. x \<in> f ` A}"]
      show ?thesis by auto
    qed
    moreover have "g \<in> restrict_space N {x. x \<notin> f ` A} \<rightarrow>\<^sub>M M"
      by (simp add: measurable_restrict_space1)
    ultimately show "h' \<in> N \<rightarrow>\<^sub>M M"
      by(simp add: h'_def measurable_If_restrict_space_iff)
  next
    fix x
    assume "x \<in> space M"
    then consider "x \<in> A" | "x \<in> space M - A" by auto
    thus "h' (h x) = x"
    proof cases
      case xa:2
      hence "h x \<notin> f ` A"
        using \<open>x \<in> space M\<close> xinA_iff by blast
      thus ?thesis
        using Acompl hfg'(4) xa by(auto simp add: h_def h'_def)
    qed(simp add: h_def h'_def \<open>x \<in> space M\<close> hfg'(1))
  next
    fix x
    assume "x \<in> space N"
    then consider "x \<in> f ` A" | "x \<in> space N -  f ` A" by auto
    thus "h (h' x) = x"
    proof cases
      case hx:1
      hence "x \<in> f ` (space M)"
        using image_mono[OF sets.sets_into_space[OF Asets],of f] by auto
      have "h' x = f' x"
        using hx by(simp add: h'_def)
      also have "... \<in> A"
        using hx sets.sets_into_space[OF Asets] hfg'(1) by auto
      finally show ?thesis
        using hfg'(2)[OF \<open>x \<in> f ` (space M)\<close>] hx by(auto simp: h_def h'_def)
    next
      case hx:2
      then have "h' x = g x"
        by(simp add: h'_def)
      also have "... \<notin> A"
      proof(rule ccontr)
        assume "\<not> g x \<notin> A"
        then have "g x \<in> A" by simp
        then obtain n where hg:"g x \<in> An n" by(auto simp: A_def)
        hence "0 < n" using hx by(auto simp: An_def)
        then obtain n' where [simp]:"n = Suc n'"
          using not0_implies_Suc by blast
        then have "g x \<in> g ` f `  An n'"
          using hg by(auto simp: An_def)
        hence "x \<in> f ` An n'"
          using inj_on_image_mem_iff[OF bij_betw_imp_inj_on[OF bij1(2)] \<open>x \<in> space N\<close>,of "f ` An n'"]
                sets.sets_into_space[OF \<open>An n' \<in> sets M\<close>] measurable_space[OF hfg2(1)] by auto
        also have "... \<subseteq> f ` A"
          by(auto simp: A_def)
        finally show False
          using hx by simp
      qed
      finally show ?thesis
        using hx hfg'(3)[OF \<open>x \<in> space N\<close>] measurable_space[OF hfg2(2) \<open>x \<in> space N\<close>]
        by(auto simp: h_def h'_def)
    qed
  qed
qed

lemma Schroeder_Bernstein_measurable:
  assumes "f \<in> M \<rightarrow>\<^sub>M N" "\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets N" "inj_on f (space M)"
      and "g \<in> N \<rightarrow>\<^sub>M M" "\<And>A. A \<in> sets N \<Longrightarrow> g ` A \<in> sets M" "inj_on g (space N)"
    shows "\<exists>h. measurable_isomorphic_map M N h"
  using Schroeder_Bernstein_measurable'[OF assms(2)[OF sets.top] assms(5)[OF sets.top] measurable_isomorphic_map_restrict_space[OF assms(1-3)] measurable_isomorphic_map_restrict_space[OF assms(4-6)]]
  by simp

lemma measurable_isomorphic_from_embeddings:
  assumes "M measurable_isomorphic (restrict_space N B)" "N measurable_isomorphic (restrict_space M A)"
      and "A \<in> sets M" "B \<in> sets N"
    shows "M measurable_isomorphic N"
proof -
  obtain f g where fg:"measurable_isomorphic_map M (restrict_space N B) f" "measurable_isomorphic_map N (restrict_space M A) g"
    using assms(1,2) by(auto simp: measurable_isomorphic_def)
  have [simp]:"f ` space M = B" "g ` space N = A"
    using measurable_isomorphic_map_surj[OF fg(1)] measurable_isomorphic_map_surj[OF fg(2)] sets.sets_into_space[OF assms(3)] sets.sets_into_space[OF assms(4)]
    by(auto simp: space_restrict_space)
  obtain h where "measurable_isomorphic_map M N h"
    using Schroeder_Bernstein_measurable'[of f M N g] assms(3,4) fg by auto
  thus ?thesis
    by(auto simp: measurable_isomorphic_def)
qed

lemma measurable_isomorphic_antisym:
  assumes "B measurable_isomorphic (restrict_space C c)" "A measurable_isomorphic (restrict_space B b)"
      and "c \<in> sets C" "b \<in> sets B" "C measurable_isomorphic A" 
    shows "C measurable_isomorphic B"
  by(rule measurable_isomorphic_from_embeddings[OF measurable_isomorphic_trans[OF assms(5,2)] assms(1) assms(3,4)])

lemma countable_infinite_isomorphisc_to_nat_index:
  assumes "countable I" and "infinite I"
  shows "(\<Pi>\<^sub>M x\<in>I. M) measurable_isomorphic (\<Pi>\<^sub>M (x::nat)\<in>UNIV. M)"
proof(rule measurable_isomorphic_byWitness[where f="\<lambda>x n. x (from_nat_into I n)" and g="\<lambda>x. \<lambda>i\<in>I. x (to_nat_on I i)"])
  show "(\<lambda>x n. x (from_nat_into I n)) \<in> (\<Pi>\<^sub>M x\<in>I. M) \<rightarrow>\<^sub>M (\<Pi>\<^sub>M (x::nat)\<in>UNIV. M)"
    by(auto intro!: measurable_PiM_single' measurable_component_singleton[OF from_nat_into[OF infinite_imp_nonempty[OF assms(2)]]])
      (simp add: PiE_iff infinite_imp_nonempty space_PiM from_nat_into[OF infinite_imp_nonempty[OF assms(2)]])
next
  show "(\<lambda>x. \<lambda>i\<in>I. x (to_nat_on I i)) \<in> (\<Pi>\<^sub>M (x::nat)\<in>UNIV. M) \<rightarrow>\<^sub>M (\<Pi>\<^sub>M x\<in>I. M)"
    by(auto intro!: measurable_PiM_single')
next
  show "x \<in> space (\<Pi>\<^sub>M x\<in>I. M) \<Longrightarrow> (\<lambda>i\<in>I. x (from_nat_into I (to_nat_on I i))) = x" for x
    by (simp add: assms(1) restrict_ext space_PiM)
next
  show "y \<in> space (Pi\<^sub>M UNIV (\<lambda>x. M)) \<Longrightarrow> (\<lambda>n. (\<lambda>i\<in>I. y (to_nat_on I i)) (from_nat_into I n)) = y" for y
    by (simp add: assms(1) assms(2) from_nat_into infinite_imp_nonempty)
qed

lemma PiM_PiM_isomorphic_to_PiM:
 "(\<Pi>\<^sub>M i\<in>I. \<Pi>\<^sub>M j\<in>J. M i j) measurable_isomorphic (\<Pi>\<^sub>M (i,j)\<in>I\<times>J. M i j)"
proof(rule measurable_isomorphic_byWitness[where f="\<lambda>x (i,j). if (i,j) \<in> I \<times> J then x i j else undefined" and g="\<lambda>x i j. if i \<notin> I then undefined j else if j \<notin> J then undefined else x (i,j)"])
  have [simp]: "(\<lambda>\<omega>. \<omega> a b) \<in> (\<Pi>\<^sub>M i\<in>I. \<Pi>\<^sub>M j\<in>J. M i j) \<rightarrow>\<^sub>M M a b" if "a \<in> I" "b \<in> J" for a b
    using measurable_component_singleton[OF that(1),of "\<lambda>i.  \<Pi>\<^sub>M j\<in>J. M i j"] measurable_component_singleton[OF that(2),of "M a"]
    by auto
  show "(\<lambda>x (i, j). if (i, j) \<in> I \<times> J then x i j else undefined) \<in> (\<Pi>\<^sub>M i\<in>I. \<Pi>\<^sub>M j\<in>J. M i j) \<rightarrow>\<^sub>M (\<Pi>\<^sub>M (i,j)\<in>I\<times>J. M i j)"
    apply(rule measurable_PiM_single')
     apply auto[1]
    apply(auto simp: PiE_def Pi_def space_PiM extensional_def;meson)
    done
next
  have [simp]: "(\<lambda>\<omega>. \<omega> (i, j))  \<in> Pi\<^sub>M (I \<times> J) (\<lambda>(i, j). M i j) \<rightarrow>\<^sub>M M i j" if "i \<in> I" "j \<in> J" for i j
    using measurable_component_singleton[of "(i,j)" "I \<times> J" "\<lambda>(i, j). M i j"] that by auto
  show "(\<lambda>x i j. if i \<notin> I then undefined j else if j \<notin> J then undefined else x (i, j)) \<in> (\<Pi>\<^sub>M (i,j)\<in>I\<times>J. M i j) \<rightarrow>\<^sub>M (\<Pi>\<^sub>M i\<in>I. \<Pi>\<^sub>M j\<in>J. M i j)"
    by(auto intro!: measurable_PiM_single') (simp_all add: PiE_iff space_PiM extensional_def)
next
  show "x \<in> space (\<Pi>\<^sub>M i\<in>I. \<Pi>\<^sub>M j\<in>J. M i j) \<Longrightarrow> (\<lambda>i j. if i \<notin> I then undefined j else if j \<notin> J then undefined else case (i, j) of (i, j) \<Rightarrow> if (i, j) \<in> I \<times> J then x i j else undefined) = x" for x
    by standard+ (auto simp: space_PiM PiE_def Pi_def extensional_def)
next
  show "y \<in> space (\<Pi>\<^sub>M (i,j)\<in>I\<times>J. M i j) \<Longrightarrow> (\<lambda>(i, j). if (i, j) \<in> I \<times> J then if i \<notin> I then undefined j else if j \<notin> J then undefined else y (i, j) else undefined) = y" for y
    by standard+ (auto simp: space_PiM PiE_def Pi_def extensional_def)
qed

lemma measurable_isomorphic_map_sigma_sets:
  assumes "sets M = sigma_sets (space M) U" "measurable_isomorphic_map M N f"
  shows "sets N = sigma_sets (space N) ((`) f ` U)"
proof -
  from measurable_isomorphic_mapD'[OF assms(2)]
  obtain g where h: "\<And>A. A \<in> sets M \<Longrightarrow> f ` A \<in> sets N" "f \<in> M \<rightarrow>\<^sub>M N" "bij_betw g (space N) (space M)" "g \<in> N \<rightarrow>\<^sub>M M" "\<And>x. x\<in>space M \<Longrightarrow> g (f x) = x" "\<And>x. x\<in>space N \<Longrightarrow> f (g x) = x" "\<And>A. A\<in>sets N \<Longrightarrow> g ` A \<in> sets M"
    by metis
  interpret s: sigma_algebra "space N"  "sigma_sets (space N) ((`) f ` U)"
    by(auto intro!: sigma_algebra_sigma_sets) (metis assms(1) h(2) measurable_space sets.sets_into_space sigma_sets_superset_generator subsetD)
  show ?thesis
  proof safe
    fix x
    assume "x \<in> sets N"
    from h(7)[OF this] assms(1)
    have "g ` x \<in> sigma_sets (space M) U" by simp
    hence "f ` (g ` x) \<in> sigma_sets (space N) ((`) f ` U)"
    proof induction
      case h:(Compl a)
      have "f ` (space M - a) = f ` (space M) - f ` a"
        by(rule inj_on_image_set_diff[where C="space M"], insert assms h) (auto simp: measurable_isomorphic_map_def bij_betw_def sets.sets_into_space)
      with h show ?case
        by (metis assms(2) measurable_isomorphic_map_surj s.Diff s.top) 
    qed (auto simp: image_UN)
    moreover have "f ` (g ` x) = x"
      using sets.sets_into_space[OF \<open>x \<in> sets N\<close>] h(6) by(fastforce simp: image_def)
    ultimately show "x \<in> sigma_sets (space N) ((`) f ` U)" by simp
  next
    interpret s': sigma_algebra "space M" "sigma_sets (space M) U"
      by(simp add: assms(1)[symmetric] sets.sigma_algebra_axioms)
    have 1:"\<And>x. x \<in> U \<Longrightarrow> x \<subseteq> space M"
      by (simp add: s'.sets_into_space)
    fix x
    assume assm:"x \<in> sigma_sets (space N) ((`) f ` U)"
    then show "x \<in> sets N"
      by induction (auto simp: assms(1) h(1))
  qed
qed

end